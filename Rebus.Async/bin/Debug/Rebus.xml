<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rebus</name>
    </assembly>
    <members>
        <member name="T:Rebus.Activation.BuiltinHandlerActivator">
            <summary>
            Built-in handler activator that can be used when dependency injection is not required, or when inline
            lambda-based handler are wanted
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Returns all relevant handler instances for the given message by looking up compatible registered functions and instance factory methods.
            </summary>
        </member>
        <member name="P:Rebus.Activation.BuiltinHandlerActivator.Bus">
            <summary>
            Gets the bus instance that this activator was configured with
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.SetBus(Rebus.Bus.IBus)">
            <summary>
            Stores the bus instance
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> and the current <see cref="T:Rebus.Pipeline.IMessageContext"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{Rebus.Bus.IBus,``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/> with the <see cref="T:Rebus.Bus.IBus"/> available
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Handle``1(System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Sets up an inline handler for messages of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Register``1(System.Func{Rebus.Bus.IBus,Rebus.Pipeline.IMessageContext,``0})">
            <summary>
            Registers the given factory method as a handler factory method for messages of the types determined by which
            <see cref="T:Rebus.Handlers.IHandleMessages`1"/> interfaces are implemeted.
            </summary>
        </member>
        <member name="M:Rebus.Activation.BuiltinHandlerActivator.Dispose">
            <summary>
            Disposes the contained bus instance
            </summary>
        </member>
        <member name="T:Rebus.Activation.IContainerAdapter">
            <summary>
            Extends <see cref="T:Rebus.Activation.IHandlerActivator"/> with the expectation that it is backed by some kind of IoC container that can hold
            a bus instance (which it naturally should be able to inject into handlers when they're activated)
            </summary>
        </member>
        <member name="M:Rebus.Activation.IContainerAdapter.SetBus(Rebus.Bus.IBus)">
            <summary>
            Sets the bus instance that this <see cref="T:Rebus.Activation.IContainerAdapter"/> should be able to inject when resolving handler instances
            </summary>
        </member>
        <member name="T:Rebus.Activation.IHandlerActivator">
            <summary>
            Responsible for creating handlers for a given message type
            </summary>
        </member>
        <member name="M:Rebus.Activation.IHandlerActivator.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Must return all relevant handler instances for the given message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.AuditHeaders">
            <summary>
            Headers relevant when using message auditing
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.AuditTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the message copy was forwarded to the audit queue.
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleTime">
            <summary>
            Header with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the audited message was received.
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.HandleQueue">
            <summary>
            Header with the queue name from which the message was received. 
            Only present on copies of handled messages (i.e. not on messages with <see cref="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe"/>
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Messages.AuditHeaders.MachineName">
            <summary>
            Name of the machine that processed/published the message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions.EnableMessageAuditing(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Enables message auditing whereby Rebus will forward to the audit queue a copy of each properly handled message and
            each published message
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.IncomingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.IncomingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Messages.OutgoingAuditingStep">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IIncomingStep"/> and <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that handles message auditing
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Messages.OutgoingAuditingStep.#ctor(Rebus.Auditing.Messages.AuditingHelper,Rebus.Transport.ITransport)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage">
            <summary>
            Saga snapshot storage that archives a snapshot of the given saga data
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.ISagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Archives the given saga data under its current ID and revision
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions">
            <summary>
            Configuration extensions for the auditing configuration
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.EnableSagaAuditing(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables message auditing whereby Rebus will forward to the audit queue a copy of each properly handled message and
            each published message
            </summary>
        </member>
        <member name="M:Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions.OutputToLog(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage})">
            <summary>
            Configures Rebus to output saga snapshots to the log. Each saga data mutation will be logged as a serialized JSON object without type information
            with INFO level to the class-logger of <see cref="T:Rebus.Auditing.Sagas.LoggerSagaSnapperShotter"/>.
            This is probably mostly useful in debugging scenarios, or as a simple auditing mechanism in cases where sagas don't expect a lot of traffic.
            </summary>
        </member>
        <member name="T:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys">
            <summary>
            Contains keys of metadata elements that can be found alongside saga data snapshots when saga auditing has been enabled
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.HandleQueue">
            <summary>
            Key of the input queue address of the endpoint that handled the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaDataType">
            <summary>
            Key of the type of the saga data
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.SagaHandlerType">
            <summary>
            Key of the type of the saga handler that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageType">
            <summary>
            Key of the type of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MessageId">
            <summary>
            Key of the ID of the message that brought the saga data to the current state
            </summary>
        </member>
        <member name="F:Rebus.Auditing.Sagas.SagaAuditingMetadataKeys.MachineName">
            <summary>
            Key of the machine name on which the saga data was brought to the current state
            </summary>
        </member>
        <member name="T:Rebus.Backoff.BackoffConfigurationExtensions">
            <summary>
            Configuration extensions for customizing the backoff behavior
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.TimeSpan[])">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="M:Rebus.Backoff.BackoffConfigurationExtensions.SetBackoffTimes(Rebus.Config.OptionsConfigurer,System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Configures the timespans to wait when backing off polling the transport during idle times. <paramref name="backoffTimes"/>
            must be a sequence of timespans, which indicates the time to wait for each second elapsed being idle. When the idle time
            exceeds the number of timespans, the last timespan will be used.
            </summary>
        </member>
        <member name="T:Rebus.Backoff.SimpleCustomizedBackoffStrategy">
            <summary>
            Simple implementation of <see cref="T:Rebus.Workers.IBackoffStrategy"/> that is capable of having the backoff times customized
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleCustomizedBackoffStrategy.#ctor(System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Constructs the backoff strategy with the given waiting times
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleCustomizedBackoffStrategy.Wait">
            <summary>
            Asynchronously executes the next wait operation, possibly advancing the wait cursor to a different wait time for the next time.
            This function is called each time no message was received.
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleCustomizedBackoffStrategy.WaitError">
            <summary>
            Asynchronously waits a while when an error has occurred
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleCustomizedBackoffStrategy.Reset">
            <summary>
            Resets the strategy. Is called whenever a message was received.
            </summary>
        </member>
        <member name="T:Rebus.Backoff.SimpleConstantPollingBackoffStrategy">
            <summary>
            Simple constant polling strategy
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleConstantPollingBackoffStrategy.Wait">
            <summary>
            Asynchronously executes the next wait operation, possibly advancing the wait cursor to a different wait time for the next time
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleConstantPollingBackoffStrategy.WaitError">
            <summary>
            Asynchronously waits a while when an error has occurred
            </summary>
        </member>
        <member name="M:Rebus.Backoff.SimpleConstantPollingBackoffStrategy.Reset">
            <summary>
            Resets the wait cursor, ensuring that the next wait operation will start over
            </summary>
        </member>
        <member name="T:Rebus.Bus.RebusBus">
            <summary>
            The implementations of the advanced APIs are private classes inside <see cref="T:Rebus.Bus.RebusBus"/> so that they can access private functions and stuff
            </summary>
            <summary>
            This is the main bus thing which you'll most likely hold on to
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.#ctor(Rebus.Workers.IWorkerFactory,Rebus.Routing.IRouter,Rebus.Transport.ITransport,Rebus.Pipeline.IPipeline,Rebus.Pipeline.IPipelineInvoker,Rebus.Subscriptions.ISubscriptionStorage,Rebus.Config.Options,Rebus.Logging.IRebusLoggerFactory,Rebus.Bus.BusLifetimeEvents,Rebus.DataBus.IDataBus)">
            <summary>
            Constructs the bus.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Start(System.Int32)">
            <summary>
            Starts the bus by adding the specified number of workers
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to this instance's own input queue, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified command message to the address mapped as the owner of the message type, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers into the future the specified message, optionally specifying some headers to attach to the message. Unless the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> is specified
            in a header, the instance's own input address will be set as the return address, which will cause the message to be delivered to that address when the <paramref name="delay"/>
            has elapsed.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Replies back to the endpoint specified as return address on the message currently being handled. Throws an <see cref="T:System.InvalidOperationException"/> if
            called outside of a proper message context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerPublish(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the specified event message on the specified topic, optionally specifying some headers to attach to the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerSubscribe(System.String)">
            <summary>
            Subscribes to the specified topic. If the current subscription storage is centralized, the subscription will be established right away. Otherwise, a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InnerUnsubscribe(System.String)">
            <summary>
            Unsubscribes from the specified topic. If the current subscription storage is centralized, the subscription will be removed right away. Otherwise, an <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/>
            will be sent to the address mapped as the owner (i.e. the publisher) of the given topic.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Dispose">
            <summary>
            Stops all workers, allowing them to finish handling the current message (for up to 1 minute) before exiting
            </summary>
        </member>
        <member name="E:Rebus.Bus.RebusBus.Disposed">
            <summary>
            Event that is raised when the bus is disposed
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers by adding/removing one worker at a time until
            the desired number is reached
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.ToString">
            <summary>
            Gets a label for this bus instance - e.g. "RebusBus 2" if this is the 2nd instance created, ever, in the current process
            </summary>
        </member>
        <member name="P:Rebus.Bus.RebusBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IAdvancedApi">
            <summary>
            API for the advanced features of the bus
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Workers">
            <summary>
            Gets an API to query/control various aspects around Rebus' workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Topics">
            <summary>
            Gets an API to do pub/sub on raw string-based topics
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.Routing">
            <summary>
            Gets an API to explicitly route messages
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.TransportMessage">
            <summary>
            Gets an API to perform operations with the transport message currently being handled
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IAdvancedApi.DataBus">
            <summary>
            Gets the API for the data bus
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IRoutingApi">
            <summary>
            Provides a raw API for explicitly routing messages to other endpoints
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IRoutingApi.Send(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Explicitly routes the <paramref name="explicitlyRoutedMessage"/> to the destination specified by <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITopicsApi">
            <summary>
            Provides the raw topic-based pub/sub API which is used underneath the type-based pub/sub api provided by <see cref="T:Rebus.Bus.IBus"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Publish(System.String,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the specified message to the specified topic. Default behavior is to look up the addresses of those who subscribed to the given topic
            by calling <see cref="M:Rebus.Subscriptions.ISubscriptionStorage.GetSubscriberAddresses(System.String)"/> but the transport may override this behavior if it has special capabilities.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Subscribe(System.String)">
            <summary>
            Subscribes the current endpoint to the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is registered immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and a
            <see cref="T:Rebus.Messages.Control.SubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITopicsApi.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the current endpoint from the given topic. If the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> is centralized (determined by checking <see cref="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized"/>),
            the subscription is removed immediately. If not, the owner of the given topic is checked (by calling <see cref="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)"/>), and an
            <see cref="T:Rebus.Messages.Control.UnsubscribeRequest"/> is sent to the owning endpoint).
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.ITransportMessageApi">
            <summary>
            Contains operations that can be performed on the transport message currently being handled
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Forward(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Forwards the transport message currently being handled to the specified queue, optionally supplying some extra headers
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.ITransportMessageApi.Defer(System.TimeSpan,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the transport message currently being handled some time into the future, optionally specifying some additional headers
            </summary>
        </member>
        <member name="T:Rebus.Bus.Advanced.IWorkersApi">
            <summary>
            Defines an API for working with workers
            </summary>
        </member>
        <member name="P:Rebus.Bus.Advanced.IWorkersApi.Count">
            <summary>
            Gets how many workers are currently running
            </summary>
        </member>
        <member name="M:Rebus.Bus.Advanced.IWorkersApi.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers, blocking until the desired number has been reached
            </summary>
        </member>
        <member name="T:Rebus.Bus.BusLifetimeEvents">
            <summary>
            Has events that can be subscribed to if one wants to be notified when certain things happen
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusDisposing">
            <summary>
            Event that is raised when the bus is disposed BEFORE the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event
            BEFORE the bus stops its workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.WorkersStopped">
            <summary>
            Event that is raised when the bus is disposed BEFORE the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event, AFTER the bus has stopped all workers
            </summary>
        </member>
        <member name="E:Rebus.Bus.BusLifetimeEvents.BusDisposed">
            <summary>
            Event that is raised when the bus is disposed AFTER the bus raises its own <see cref="E:Rebus.Bus.RebusBus.Disposed"/> event
            </summary>
        </member>
        <member name="T:Rebus.Bus.IBus">
            <summary>
            This is the main bus API
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to our own input queue address
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to a destination that is determined by calling <see cref="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified reply message to a destination that is determined by looking up the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header of the message currently being handled.
            This method can only be called from within a message handler.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the delivery of the message by attaching a <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to it and delivering it to the configured timeout manager endpoint
            (defaults to be ourselves). When the time is right, the deferred message is returned to the address indicated by the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header.
            </summary>
        </member>
        <member name="P:Rebus.Bus.IBus.Advanced">
            <summary>
            Gets the API for advanced features of the bus
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.IBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="T:Rebus.Bus.IInitializable">
            <summary>
            Anything that is resolved with the injectionist can be marked as initializable by implementing this interface, which
            will then have its <see cref="M:Rebus.Bus.IInitializable.Initialize"/> method called before the bus is started
            </summary>
        </member>
        <member name="M:Rebus.Bus.IInitializable.Initialize">
            <summary>
            Initializes the instance
            </summary>
        </member>
        <member name="T:Rebus.Bus.MessageExtensions">
            <summary>
            Small helpers that make it easier to work with the <see cref="T:Rebus.Messages.Message"/> class
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.HasReturnAddress(Rebus.Messages.Message)">
            <summary>
            Gets whether the message's <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header is set to something
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetReturnAddressFromTransport(Rebus.Messages.Message,Rebus.Transport.ITransport)">
            <summary>
            Uses the transport's input queue address as the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> on the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeaders(Rebus.Messages.Message,System.DateTimeOffset,System.String)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.SetDeferHeaders(Rebus.Messages.TransportMessage,System.DateTimeOffset,System.String)">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to the specified time
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageType(Rebus.Messages.Message)">
            <summary>
            Gets the message type from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.Message)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageId(Rebus.Messages.TransportMessage)">
            <summary>
            Gets the message ID from the message
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.Message)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.GetMessageLabel(Rebus.Messages.TransportMessage)">
            <summary>
            Gets a nice label for the message, consisting of message type and ID if possible
            </summary>
        </member>
        <member name="M:Rebus.Bus.MessageExtensions.Clone(Rebus.Messages.TransportMessage)">
            <summary>
            Returns a cloned instance of the transport message
            </summary>
        </member>
        <member name="T:Rebus.Compression.DataCompressionMode">
            <summary>
            Enumerates strategies for when the data bus storage decorator GZIps the data
            </summary>
        </member>
        <member name="F:Rebus.Compression.DataCompressionMode.Always">
            <summary>
            Always compresses data. Please note that this requires that data can be kept in memory as this
            is required by the streaming APIs used when compressing data
            </summary>
        </member>
        <member name="F:Rebus.Compression.DataCompressionMode.Explicit">
            <summary>
            Compresses data when the <see cref="F:Rebus.DataBus.MetadataKeys.ContentEncoding"/> key is detected among the metadata
            of the save data and the value is "gzip"
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZippingDataBusStorageDecorator">
            <summary>
            Decorator for <see cref="T:Rebus.DataBus.IDataBusStorage"/> that GZIP-compresses data when it is streamed in/out
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.#ctor(Rebus.DataBus.IDataBusStorage,Rebus.Compression.DataCompressionMode)">
            <summary>
            Creates the decorator, wrapping the given <paramref name="innerDataBusStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZippingDataBusStorageDecorator.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="T:Rebus.Compression.ZipConfigurationExtensions">
            <summary>
            Configuration extensions for enabling compression
            </summary>
        </member>
        <member name="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes">
            <summary>
            Default threshold for the body size for compression to kick in
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.EnableCompression(Rebus.Config.OptionsConfigurer,System.Int32)">
            <summary>
            Enables compression of outgoing messages if the size exceeds the specified number of bytes
            (defaults to <see cref="F:Rebus.Compression.ZipConfigurationExtensions.DefaultBodyThresholdBytes"/>)
            </summary>
        </member>
        <member name="M:Rebus.Compression.ZipConfigurationExtensions.UseCompression(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.Compression.DataCompressionMode)">
            <summary>
            Enables GZIP of the saved data bus data. Set <paramref name="dataCompressionMode"/> to control when data is gzipped - if <see cref="F:Rebus.Compression.DataCompressionMode.Always"/>
            is selected the data will always be GZIPped, whereas selecting <see cref="F:Rebus.Compression.DataCompressionMode.Explicit"/> makes the data be GZIPped
            only when <see cref="F:Rebus.DataBus.MetadataKeys.ContentEncoding"/> = "gzip" is detected among the metadata for the stored data.
            Please note that GZIPping the data requires that it can be fully contained in memory because the underlying streaming APIs do not support lazy-reading a
            GZIP stream.
            </summary>
        </member>
        <member name="T:Rebus.Compression.Zipper">
            <summary>
            Zipper that holds the zipping logic
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Zip(System.Byte[])">
            <summary>
            Zips the byte array
            </summary>
        </member>
        <member name="M:Rebus.Compression.Zipper.Unzip(System.Byte[])">
            <summary>
            Unzips the byte array
            </summary>
        </member>
        <member name="T:Rebus.Config.OneWayClientBackdoor">
            <summary>
            Helper that gives a backdoor to the configuration <see cref="T:Rebus.Config.Options"/>, allowing for one-way client settings
            to be set.
            </summary>
        </member>
        <member name="M:Rebus.Config.OneWayClientBackdoor.ConfigureOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport})">
            <summary>
            Uses the given <see cref="T:Rebus.Config.StandardConfigurer`1"/> of <see cref="T:Rebus.Transport.ITransport"/> to set the number of workers
            to zero (effectively disabling message processing) and installs a decorator of <see cref="T:Rebus.Bus.IBus"/> that prevents
            further modification of the number of workers (thus preventing accidentally starting workers when there's no input queue).
            </summary>
        </member>
        <member name="T:Rebus.Config.RebusLoggingConfigurer">
            <summary>
            Configurer that is used to configure logging. This configurer is cheating a little bit because it will actually modify a global logger which will
            be used throughout all Rebus instances. This mechanism might change in the future
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Console(Rebus.Logging.LogLevel)">
            <summary>
            Configures Rebus to log its stuff to stdout, possibly ignore logged lines under the specified <see cref="T:Rebus.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.ColoredConsole(Rebus.Logging.LogLevel)">
            <summary>
            Configures Rebus to log its stuff to with different colors depending on the log level, possibly ignore logged lines under the specified <see cref="T:Rebus.Logging.LogLevel"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Trace">
            <summary>
            Configures Rebus to log its stuff to <see cref="T:System.Diagnostics.Trace"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.None">
            <summary>
            Disables logging alltogether
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusLoggingConfigurer.Use(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Configures this Rebus instance to use the specified logger factory
            </summary>
        </member>
        <member name="T:Rebus.Config.Configure">
            <summary>
            Configuration entry point - call the static <see cref="M:Rebus.Config.Configure.With(Rebus.Activation.IHandlerActivator)"/> method with the chosen implementation of <see cref="T:Rebus.Activation.IHandlerActivator"/> 
            (e.g. <see cref="T:Rebus.Activation.BuiltinHandlerActivator"/>, or one that is backed by your favorite IoC container) in order to start configuring a
            Rebus instance
            </summary>
        </member>
        <member name="M:Rebus.Config.Configure.With(Rebus.Activation.IHandlerActivator)">
            <summary>
            Call this method with the chosen implementation of <see cref="T:Rebus.Activation.IHandlerActivator"/> (e.g. <see cref="T:Rebus.Activation.BuiltinHandlerActivator"/>, or one 
            that is backed by your favorite IoC container) in order to start configuring a
            Rebus instance
            </summary>
        </member>
        <member name="T:Rebus.Config.Options">
            <summary>
            Contains additional options for configuring Rebus internals
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultNumberOfWorkers">
            <summary>
            This is the default number of workers that will be started, unless <see cref="P:Rebus.Config.Options.NumberOfWorkers"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultMaxParallelism">
            <summary>
            This is the default number of concurrent asynchrounous operations allowed, unless <see cref="P:Rebus.Config.Options.MaxParallelism"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Config.Options.DefaultWorkerShutdownTimeout">
            <summary>
            This is the default timeout for workers to finish running active handlers, unless <see cref="P:Rebus.Config.Options.WorkerShutdownTimeout" /> is set to something else.
            </summary>
            <value>1 minute per default.</value>
        </member>
        <member name="F:Rebus.Config.Options.DefaultDueTimeoutsPollInterval">
            <summary>
            This is the default due timeouts poll interval which will be used unless overridde by <see cref="P:Rebus.Config.Options.DueTimeoutsPollInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.Options.#ctor">
            <summary>
            Constructs the options with the default settings
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.NumberOfWorkers">
            <summary>
            Configures the number of workers. If thread-based workers are used, this is the number of threads that will be created.
            This number should be less than or equal to <see cref="P:Rebus.Config.Options.MaxParallelism"/>.
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.MaxParallelism">
            <summary>
            Configures the total degree of parallelism allowed. This will be the maximum number of parallel potentially asynchrounous operations that can be active,
            regardless of the number of workers
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.ExternalTimeoutManagerAddressOrNull">
            <summary>
            Gets/sets the address to use if an external timeout manager is to be used
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.DueTimeoutsPollInterval">
            <summary>
            Gets/sets the poll interval when checking for due timeouts
            </summary>
        </member>
        <member name="P:Rebus.Config.Options.WorkerShutdownTimeout">
            <summary>
            Gets/sets the maximum timeout for workers to finish running active handlers after being signaled to stop.
            </summary>
        </member>
        <member name="T:Rebus.Config.OptionsConfigurer">
            <summary>
            Allows for configuring additional options
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetNumberOfWorkers(System.Int32)">
            <summary>
            Configures the number of workers to start competing over the input queue
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetMaxParallelism(System.Int32)">
            <summary>
            Configures the total degree of parallelism allowed. This will be the maximum number of parallel potentially asynchrounous operations that can be active,
            regardless of the number of workers
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetWorkerShutdownTimeout(System.TimeSpan)">
            <summary>
            Configures the maximum timeout for workers to finish running active handlers after being signaled to stop.
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.SetDueTimeoutsPollInteval(System.TimeSpan)">
            <summary>
            Configures the interval between polling the endpoint's configured <see cref="T:Rebus.Timeouts.ITimeoutManager"/> for due timeouts.
            Defaults to <see cref="F:Rebus.Config.Options.DefaultDueTimeoutsPollInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolver of the given primary implementation of the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Has``1">
            <summary>
            Gets whether a primary implementation resolver has been registered for the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given decorator of the <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.OptionsConfigurer.LogPipeline(System.Boolean)">
            <summary>
            Outputs the layout of the send and receive pipelines to the log
            </summary>
        </member>
        <member name="T:Rebus.Config.RebusConfigurer">
            <summary>
            Basic skeleton of the fluent configuration builder. Contains a method for each aspect that can be configured
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Logging(System.Action{Rebus.Config.RebusLoggingConfigurer})">
            <summary>
            Configures how Rebus logs stuff that happens
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Transport(System.Action{Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport}})">
            <summary>
            Configures how Rebus sends/receives messages by allowing for choosing which implementation of <see cref="T:Rebus.Transport.ITransport"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Routing(System.Action{Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter}})">
            <summary>
            Configures how Rebus routes messages by allowing for choosing which implementation of <see cref="T:Rebus.Routing.IRouter"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Sagas(System.Action{Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage}})">
            <summary>
            Configures how Rebus persists saga data by allowing for choosing which implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Subscriptions(System.Action{Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage}})">
            <summary>
            Configures how Rebus persists subscriptions by allowing for choosing which implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Serialization(System.Action{Rebus.Config.StandardConfigurer{Rebus.Serialization.ISerializer}})">
            <summary>
            Configures how Rebus serializes messages by allowing for choosing which implementation of <see cref="T:Rebus.Serialization.ISerializer"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Timeouts(System.Action{Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager}})">
            <summary>
            Configures how Rebus defers messages to the future by allowing for choosing which implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to use
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Options(System.Action{Rebus.Config.OptionsConfigurer})">
            <summary>
            Configures additional options about how Rebus works
            </summary>
        </member>
        <member name="M:Rebus.Config.RebusConfigurer.Start">
            <summary>
            Finishes the setup of the bus, using default implementations for the options that have not explicitly been set.
            The only requirement, is that you must call <see cref="M:Rebus.Config.RebusConfigurer.Transport(System.Action{Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport}})"/> and select which transport to use - everything
            else can run with a default option. It should be noted though, that several of the defaults (e.g. in-mem persistence
            options for saga storage, subscriptions, and timeouts) are not meant for production use, and should probably be
            replaced by something that is actually persistent.
            </summary>
        </member>
        <member name="T:Rebus.Config.StandardConfigurer`1">
            <summary>
            Configurer that can have extension methods attached to it for helping with registering an implementation or a decorator
            for the <typeparamref name="TService"/> service.
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.GetConfigurerFrom(Rebus.Config.OptionsConfigurer)">
            <summary>
            Gets a standard configurer from the given options configurer. Can be used to provide
            extensions to <see cref="T:Rebus.Config.OptionsConfigurer"/> that return a standard configurer that can then
            be used to build further
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.Register(System.Func{Rebus.Injection.IResolutionContext,`0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.Decorate(System.Func{Rebus.Injection.IResolutionContext,`0},System.String)">
            <summary>
            Registers the given factory function as a resolve of the given <typeparamref name="TService"/> service
            </summary>
        </member>
        <member name="M:Rebus.Config.StandardConfigurer`1.OtherService``1">
            <summary>
            Gets a typed configurer for another service. Can be useful if e.g. a configuration extension for a <see cref="T:Rebus.Transport.ITransport"/>
            wants to replace the <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> because it is capable of using the transport layer to do pub/sub
            </summary>
        </member>
        <member name="T:Rebus.DataBus.DataBusAttachment">
            <summary>
            Model that represents a data bus attachment. Only the <see cref="P:Rebus.DataBus.DataBusAttachment.Id"/> is significant, as all the
            other pieces of information are not required in order to retrieve the attachment from the database.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.#ctor(System.String)">
            <summary>
            Creates a data bus attachment with the given ID
            </summary>
        </member>
        <member name="P:Rebus.DataBus.DataBusAttachment.Id">
            <summary>
            Gets the ID of the attachment
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.OpenRead">
            <summary>
            Opens the attachment for reading, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.GetMetadata">
            <summary>
            Gets the metadata associated with the attachment, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.OpenRead(System.String)">
            <summary>
            Opens the attachment for reading, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusAttachment.GetMetadata(System.String)">
            <summary>
            Gets the metadata associated with the attachment, using the data bus of the bus that is handling the current message to read it.
            Is only available for calling inside message handlers.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.DataBusOptionsExtensions">
            <summary>
            Configuration extensions for Rebus' data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.DataBusOptionsExtensions.EnableDataBus(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables the data bus
            </summary>
        </member>
        <member name="T:Rebus.DataBus.FileSystem.FileSystemDataBusExtensions">
            <summary>
            Provides extensions methods for configuring the file system storage for the data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusExtensions.StoreInFileSystem(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.String)">
            <summary>
            Configures the data bus to store data in the file system
            </summary>
        </member>
        <member name="T:Rebus.DataBus.FileSystem.FileSystemDataBusStorage">
            <summary>
            Implementation of <see cref="T:Rebus.DataBus.IDataBusStorage"/> that stores data in the file system. Could be a directory on a network share.
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the data storage
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Initialize">
            <summary>
            Initializes the file system data storage by ensuring that the configured data directory path exists and that it is writable
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given strea under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.Read(System.String)">
            <summary>
            Reads the data with the given ID and returns it as a stream
            </summary>
        </member>
        <member name="M:Rebus.DataBus.FileSystem.FileSystemDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="T:Rebus.DataBus.InMem.InMemDataBusExtensions">
            <summary>
            Configuration extensions for the in-mem data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataBusExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.DataBus.InMem.InMemDataStore)">
            <summary>
            Configures the data bus to store data in memory. This is probably only useful for test scenarios, as the
            passed-in <paramref name="inMemDataStore"/> needs to be shared among endpoints on the data bus.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.InMem.InMemDataStore">
            <summary>
            In-mem implementation of a data store that can be shared among buses that use the in-mem data bus.
            A shared instance of this class should be passed to all endpoints when calling <see cref="M:Rebus.DataBus.InMem.InMemDataBusExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},Rebus.DataBus.InMem.InMemDataStore)"/>
            </summary>
        </member>
        <member name="P:Rebus.DataBus.InMem.InMemDataStore.SizeBytes">
            <summary>
            Gets the total size in bytes 
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Save(System.String,System.Byte[],System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the given bytes under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.Load(System.String)">
            <summary>
            Loads the bytes with the given ID. Throws a <see cref="T:System.ArgumentException"/> if no
            such ID exists
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.AddMetadata(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Adds the metadata from the <paramref name="metadata"/> dictionary to the blob with the given <paramref name="id"/>
            </summary>
        </member>
        <member name="M:Rebus.DataBus.InMem.InMemDataStore.LoadMetadata(System.String)">
            <summary>
            Loads the metadata for the data with the given ID. Throws a <see cref="T:System.ArgumentException"/> if no
            such ID exists
            </summary>
        </member>
        <member name="T:Rebus.DataBus.IDataBus">
            <summary>
            API for Rebus' data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBus.CreateAttachment(System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Creates an attachment from the given source stream, optionally providing some extra metadata to be stored along with the attachment
            </summary>
        </member>
        <member name="T:Rebus.DataBus.IDataBusStorage">
            <summary>
            Abstraction over the data bus storage
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.DataBus.IDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="T:Rebus.DataBus.MetadataKeys">
            <summary>
            Contains keys of standard metadata which is always available on data stored with the data bus
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.Length">
            <summary>
            Metadata key of the length in bytes of the stored data
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.SaveTime">
            <summary>
            Metadata key of the ISO8601-encoded time of when the data was stored
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ReadTime">
            <summary>
            Metadata key of the ISO8601-encoding time of when the data was last read
            </summary>
        </member>
        <member name="F:Rebus.DataBus.MetadataKeys.ContentEncoding">
            <summary>
            Optional header that might contain an encoding of the contents, e.g."gzip" for gzipped data.
            </summary>
        </member>
        <member name="T:Rebus.DataBus.SqlServer.SqlServerDataBusConfigurationExtensions">
            <summary>
            Configuration extensions for SQL Server data bus
            </summary>
        </member>
        <member name="M:Rebus.DataBus.SqlServer.SqlServerDataBusConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.String,System.String,System.Boolean)">
            <summary>
            Configures the data bus to store data in a central SQL Server 
            </summary>
        </member>
        <member name="M:Rebus.DataBus.SqlServer.SqlServerDataBusConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.DataBus.IDataBusStorage},System.Func{System.Threading.Tasks.Task{Rebus.Persistence.SqlServer.IDbConnection}},System.String,System.Boolean)">
            <summary>
            Configures the data bus to store data in a central SQL Server 
            </summary>
        </member>
        <member name="T:Rebus.DataBus.SqlServer.SqlServerDataBusStorage">
            <summary>
            Implementation of <see cref="T:Rebus.DataBus.IDataBusStorage"/> that uses SQL Server to store data
            </summary>
        </member>
        <member name="M:Rebus.DataBus.SqlServer.SqlServerDataBusStorage.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,System.Boolean,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the data storage
            </summary>
        </member>
        <member name="M:Rebus.DataBus.SqlServer.SqlServerDataBusStorage.Initialize">
            <summary>
            Initializes the SQL Server data storage.
            Will create the data table, unless this has been explicitly turned off when configuring the data storage
            </summary>
        </member>
        <member name="M:Rebus.DataBus.SqlServer.SqlServerDataBusStorage.Save(System.String,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves the data from the given source stream under the given ID
            </summary>
        </member>
        <member name="M:Rebus.DataBus.SqlServer.SqlServerDataBusStorage.Read(System.String)">
            <summary>
            Opens the data stored under the given ID for reading
            </summary>
        </member>
        <member name="M:Rebus.DataBus.SqlServer.SqlServerDataBusStorage.ReadMetadata(System.String)">
            <summary>
            Loads the metadata stored with the given ID
            </summary>
        </member>
        <member name="T:Rebus.Encryption.DecryptMessagesIncomingStep">
            <summary>
            Incoming message step that checks for the prensence of the <see cref="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption"/> header, decrypting
            the message body if it is present.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DecryptMessagesIncomingStep.#ctor(Rebus.Encryption.IEncryptor)">
            <summary>
            Constructs the step with the given encryptor
            </summary>
        </member>
        <member name="M:Rebus.Encryption.DecryptMessagesIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Descrypts the incoming <see cref="T:Rebus.Messages.TransportMessage"/> if it has the <see cref="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption"/> header
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptedData">
            <summary>
            Represents a chunk of encrypted data along with the salt (a.k.a. "Initialization Vector"/"IV") that was used to encrypt it.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptedData.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Constructs an instance from the given bytes and iv.
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.Iv">
            <summary>
            Gets the salt (a.k.a. "Initialization Vector"/"IV") from this encrypted data instance
            </summary>
        </member>
        <member name="P:Rebus.Encryption.EncryptedData.Bytes">
            <summary>
            Gets the raw data from this encrypted data instance
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptionConfigurationExtensions">
            <summary>
            Configuration extensions for enabling encrypted message bodies
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableEncryption(Rebus.Config.OptionsConfigurer,System.String)">
            <summary>
            Configures Rebus to encrypt outgoing messages and be able to decrypt incoming messages. 
            Uses the default "Rijndael" algorithm which is 256 bit AES encryption.
            Please note that it's only the message bodies that are encrypted, thus everything included in the message headers will be visible to eavesdroppers.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptionConfigurationExtensions.EnableCustomEncryption(Rebus.Config.OptionsConfigurer)">
            <summary>
            Configures Rebus to encrypt outgoing messages and be able to decrypt incoming messages using custom encryption provider.
            Please note that it's only the message bodies that are encrypted, thus everything included in the message headers will be visible to eavesdroppers.
            Custom encrypotion providers are configured by building on the returned configurer, e.g. like so:
            <code>
            Configure.With(...)
                .(...)
                .Options(o => {
                    o.EnableCustomEncryption()
                        .Use***();
                })
                .Start();
            </code>
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptionHeaders">
            <summary>
            Special headers that are used when the message contents are encrypted
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.ContentEncryption">
            <summary>
            Optional header element that specifies an encryption algorithm that the contents have been encrypted with
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.ContentInitializationVector">
            <summary>
            When the contents have been encrypted, this header has the IV
            </summary>
        </member>
        <member name="F:Rebus.Encryption.EncryptionHeaders.DisableEncryptionHeader">
            <summary>
            Special header that can be added to a message in order to disable encryption for that particular message
            </summary>
        </member>
        <member name="T:Rebus.Encryption.EncryptMessagesOutgoingStep">
            <summary>
            Outgoing pipeline step that encrypts the contents of the outgoing message
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptMessagesOutgoingStep.#ctor(Rebus.Encryption.IEncryptor)">
            <summary>
            Constructs the step with the given encryptor
            </summary>
        </member>
        <member name="M:Rebus.Encryption.EncryptMessagesOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Encrypts the outgoing <see cref="T:Rebus.Messages.TransportMessage"/> and adds appropriate headers
            </summary>
        </member>
        <member name="T:Rebus.Encryption.RijndaelEncryptor">
            <summary>
            Helps with encrypting/decripting byte arrays, using the <see cref="T:System.Security.Cryptography.RijndaelManaged"/> algorithm
            </summary>
        </member>
        <member name="P:Rebus.Encryption.RijndaelEncryptor.ContentEncryptionValue">
            <summary>
            Returns "rijndael" string
            </summary>
        </member>
        <member name="M:Rebus.Encryption.RijndaelEncryptor.#ctor(System.String)">
            <summary>
            Creates the encrptor with the specified key - the key must be a valid, base64-encoded key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Rebus.Encryption.RijndaelEncryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given array of bytes, using the configured key. Returns an <see cref="T:Rebus.Encryption.EncryptedData"/> containing the encrypted
            bytes and the generated salt.
            </summary>
        </member>
        <member name="M:Rebus.Encryption.RijndaelEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the given <see cref="T:Rebus.Encryption.EncryptedData"/> using the configured key.
            </summary>
        </member>
        <member name="T:Rebus.Encryption.IEncryptor">
            <summary>
            Interface to provide encryption/decryption custom implementation
            </summary>
        </member>
        <member name="P:Rebus.Encryption.IEncryptor.ContentEncryptionValue">
            <summary>
            Header name that will be added to an encrypted message
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IEncryptor.Decrypt(Rebus.Encryption.EncryptedData)">
            <summary>
            Decrypts the encrypted data
            </summary>
        </member>
        <member name="M:Rebus.Encryption.IEncryptor.Encrypt(System.Byte[])">
            <summary>
            Encrypts the given bytes and returns the encrypted data alond with the salt in the returned <see cref="T:Rebus.Encryption.EncryptedData"/>
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.RebusApplicationException">
            <summary>
            Generic application exception to use when something bad happens that is pretty unexpected and should be taken seriously
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.String)">
            <summary>
            Constructs the exception with the given message
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.Exception,System.String)">
            <summary>
            Constructs the exception with the given message and inner exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.RebusApplicationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Happy cross-domain serialization!
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.Ignorant">
            <summary>
            Helps keeping track of errors that we want to ignore for a while before acknowledging them
            </summary>
        </member>
        <member name="P:Rebus.Exceptions.Ignorant.SilencePeriods">
            <summary>
            Gets/sets the silence periods, i.e. the length of the intervals in which the ignorant will be silent
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.#ctor(System.Func{System.Exception,System.String})">
            <summary>
            Constructs the ignorant with the given mapping from an exception instance to the equality key that will be used to compare with previous exceptions.
            If no equality key mapper is given, it will default to using <see cref="P:System.Type.FullName"/> of the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.IsToBeIgnored(System.Exception)">
            <summary>
            Checks whether the given exception is to be ignored
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.Ignorant.Reset">
            <summary>
            Resets the silence period tracker - should be called after each success
            </summary>
        </member>
        <member name="T:Rebus.Exceptions.ConcurrencyException">
            <summary>
            Special exception that signals that some kind of optimistic lock has been violated, and work must most likely be aborted &amp; retried
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.String,System.Object[])">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Exceptions.ConcurrencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="T:Rebus.Extensions.DateTimeExtensions">
            <summary>
            Defines a few nice extensions for making working with <see cref="T:System.DateTimeOffset"/> more nice
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ElapsedUntilNow(System.DateTimeOffset)">
            <summary>
            Gets the time from this instant until now (as returned by <see cref="P:Rebus.Time.RebusTime.Now"/>)
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ToIso8601DateTimeOffset(System.DateTimeOffset)">
            <summary>
            Serializes this instant with the "O" format, i.e. ISO8601-compliant
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DateTimeExtensions.ToDateTimeOffset(System.String)">
            <summary>
            Parses an ISO8601-compliant string into a proper <see cref="T:System.DateTimeOffset"/>
            </summary>
        </member>
        <member name="T:Rebus.Extensions.TypeExtensions">
            <summary>
            Provides extensions of <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.TypeExtensions.GetBaseTypes(System.Type)">
            <summary>
            Gets the type's base types (i.e. the <see cref="T:System.Type"/> for each implemented interface and for each class inherited from, all the way up to <see cref="T:System.Object"/>)
            </summary>
        </member>
        <member name="M:Rebus.Extensions.TypeExtensions.GetSimpleAssemblyQualifiedName(System.Type)">
            <summary>
            Gets the assembly-qualified name of the type, without any version info etc.
            E.g. "System.String, mscorlib"
            </summary>
        </member>
        <member name="T:Rebus.Extensions.EnumerableExtensions">
            <summary>
            Nifty extensions for <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the items of the sequence in a new <see cref="T:System.Collections.Generic.HashSet`1"/> 
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns the items of the sequence in a new <see cref="T:System.Collections.Generic.HashSet`1"/>, checking equality with the given <paramref name="equalityComparer"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Iterates the sequence, calling the given <paramref name="itemAction"/> for each item
            </summary>
        </member>
        <member name="T:Rebus.Extensions.DictionaryExtensions">
            <summary>
            Provides some nifty extensions to <see cref="T:System.Collections.Generic.Dictionary`2"/> and <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.MergedWith``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns a new dictionary that contains all key-value pairs from both dictionaries. If the same key is present the value from <paramref name="otherDictionary"/> takes precedence
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.Clone(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Returns a new dictionary with the same key-value pairs as the target
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetValue(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Gets the value with the given key from the dictionary, throwing a MUCH nicer <see cref="T:System.Collections.Generic.KeyNotFoundException"/>
            if the key does not exist
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetValueOrNull(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Gets the value with the given key from the dictionary, returning null if the key does not exist
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{``0})">
            <summary>
            Provides a function similar to <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})"/>, only
            on <see cref="T:System.Collections.Generic.Dictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrAddAsync``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Provides a function similar to <see cref="M:Rebus.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{System.String,``1},System.String,System.Func{``0})"/>, only where the factory function can be async
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.ToConcurrentDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Maps the given sequence of items to key-value pairs, returning them in a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrThrow``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, throwing a nice exception if either the key
            does not exist, or the found value cannot be cast to the given type
            </summary>
        </member>
        <member name="M:Rebus.Extensions.DictionaryExtensions.GetOrNull``1(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, returning null if the key does not exist.
            If the key exists, but the object could not be cast to the given type, a nice exception is throws
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration">
            <summary>
            Configurer returned from <see cref="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1"/> that allows for specifying additional handler types
            whose order to fix
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1">
            <summary>
            Specifies the handler that will be put next in the pipeline if it is present - call <see cref="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1"/>
            again to specify the next handler
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.ReorderingConfiguration">
            <summary>
            Configurer returned from <see cref="M:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions.SpecifyOrderOfHandlers(Rebus.Config.OptionsConfigurer)"/> that can be used as a
            fluent syntax to specify the desired order of the handlers
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1">
            <summary>
            Specifies the handler that will be put first in the pipeline if it is present - call <see cref="M:Rebus.Handlers.Reordering.AdditionalReorderingConfiguration.Then``1"/>
            any number of times to specify the next handler
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.ReorderingConfiguration.GetIndex(System.Object)">
            <summary>
            Gets the sorting index for the given handler
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions">
            <summary>
            Configuration extensions for setting up an order of handlers that must be respected when
            two or more of the handlers are present in the same handler pipeline
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions.SpecifyOrderOfHandlers(Rebus.Config.OptionsConfigurer)">
            <summary>
            Initiates the configuration of the handler ordering - call <see cref="M:Rebus.Handlers.Reordering.ReorderingConfiguration.First``1"/> in
            order to specify the handler that will be put first in the pipeline if it is present
            </summary>
        </member>
        <member name="T:Rebus.Handlers.Reordering.HandlerReorderingStep">
            <summary>
            Incoming message step that can reorder handlers
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingStep.#ctor(Rebus.Handlers.Reordering.ReorderingConfiguration)">
            <summary>
            Constructs the step with the given configuration
            </summary>
        </member>
        <member name="M:Rebus.Handlers.Reordering.HandlerReorderingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Reorders the handler invokers if necessary
            </summary>
        </member>
        <member name="T:Rebus.Handlers.IHandleMessages">
            <summary>
            Base message handler interface. Don't implement this one directly, it would give you nothing
            </summary>
        </member>
        <member name="T:Rebus.Handlers.IHandleMessages`1">
            <summary>
            Message handler interface. Implement this in order to get to handle messages of a specific type
            </summary>
        </member>
        <member name="M:Rebus.Handlers.IHandleMessages`1.Handle(`0)">
            <summary>
            This method will be invoked with a message of type <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Handlers.InternalHandlersContributor">
            <summary>
            Decoration of <see cref="T:Rebus.Activation.IHandlerActivator"/> that adds a few special handlers when an incoming message can be recognized
            as a special Rebus message
            </summary>
        </member>
        <member name="M:Rebus.Handlers.InternalHandlersContributor.GetHandlers``1(``0,Rebus.Transport.ITransactionContext)">
            <summary>
            Gets Rebus' own internal handlers (if any) for the given message type
            </summary>
        </member>
        <member name="T:Rebus.Injection.Injectionist">
            <summary>
            Dependency injectionist that can be used for configuring a system of injected service implementations, possibly with decorators,
            with caching of instances so that the same instance of each class is used throughout the tree. Should probably not be used for
            anything at runtime, is only meant to be used in configuration scenarios.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Get``1">
            <summary>
            Starts a new resolution context, resolving an instance of the given <typeparamref name="TService"/>
            </summary>
        </member>
        <member name="E:Rebus.Injection.Injectionist.ResolveRequested">
            <summary>
            Events that is raised when the resolution of a top-level instance is requested
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Register``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers a factory method that can provide an instance of <typeparamref name="TService"/>. Optionally,
            the supplied <paramref name="description"/> will be used to report more comprehensible errors in case of
            conflicting registrations.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Decorate``1(System.Func{Rebus.Injection.IResolutionContext,``0},System.String)">
            <summary>
            Registers a decorator factory method that can provide an instance of <typeparamref name="TService"/> 
            (i.e. the resolver is expected to call <see cref="M:Rebus.Injection.IResolutionContext.Get``1"/> where TService
            is <typeparamref name="TService"/>. Optionally, the supplied <paramref name="description"/> will be used 
            to report more comprehensible errors in case of conflicting registrations.
            </summary>
        </member>
        <member name="M:Rebus.Injection.Injectionist.Has``1(System.Boolean)">
            <summary>
            Returns whether there exists a registration for the specified <typeparamref name="TService"/>.
            </summary>
        </member>
        <member name="T:Rebus.Injection.IResolutionContext">
            <summary>
            Represents the context of resolving one root service and can be used throughout the tree to fetch something to be injected
            </summary>
        </member>
        <member name="M:Rebus.Injection.IResolutionContext.Get``1">
            <summary>
            Gets an instance of the specified <typeparamref name="TService"/>.
            </summary>
        </member>
        <member name="P:Rebus.Injection.IResolutionContext.TrackedInstances">
            <summary>
            Gets all instances resolved within this resolution context at this time.
            </summary>
        </member>
        <member name="T:Rebus.Injection.ResolutionException">
            <summary>
            Exceptions that is thrown when something goes wrong while working with the injectionist
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.String,System.Object[])">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="M:Rebus.Injection.ResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructs the exception
            </summary>
        </member>
        <member name="T:Rebus.Injection.ResolutionResult`1">
            <summary>
            Contains a built object instance along with all the objects that were used to build the instance
            </summary>
        </member>
        <member name="P:Rebus.Injection.ResolutionResult`1.Instance">
            <summary>
            Gets the instance that was built
            </summary>
        </member>
        <member name="P:Rebus.Injection.ResolutionResult`1.TrackedInstances">
            <summary>
            Gets all object instances that were used to build <see cref="P:Rebus.Injection.ResolutionResult`1.Instance"/>, including the instance itself
            </summary>
        </member>
        <member name="T:Rebus.Messages.HeaderAttribute">
            <summary>
            Header attribute that can be used to automatically add some specific header to all outgoing messages
            </summary>
        </member>
        <member name="P:Rebus.Messages.HeaderAttribute.Key">
            <summary>
            Gets the key of the header
            </summary>
        </member>
        <member name="P:Rebus.Messages.HeaderAttribute.Value">
            <summary>
            Gets the value of the header
            </summary>
        </member>
        <member name="M:Rebus.Messages.HeaderAttribute.#ctor(System.String,System.String)">
            <summary>
            Creates the header attribute with the given key and value
            </summary>
        </member>
        <member name="M:Rebus.Messages.HeaderAttribute.#ctor(System.String)">
            <summary>
            Creates the header attribute with the given key and an empty value
            </summary>
        </member>
        <member name="T:Rebus.Messages.Control.SubscribeRequest">
            <summary>
            Control message that can be used to establish a subscription of a given topic to the endpoint with the given address.
            The receiving endpoint must either be the one publishing messages with the given topic, or it must have a connection
            to a centralized subscription storage
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.SubscribeRequest.SubscriberAddress">
            <summary>
            Specifies the globally addressable queue address of the subscriber to enlist for the given topic
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.SubscribeRequest.Topic">
            <summary>
            Specifis the topic for which the subscriber wishes to subscribe
            </summary>
        </member>
        <member name="T:Rebus.Messages.Control.UnsubscribeRequest">
            <summary>
            Control message that can be used to end a subscription of a given topic to the endpoint with the given address.
            The receiving endpoint must either be the one publishing messages with the given topic, or it must have a connection
            to a centralized subscription storage
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.UnsubscribeRequest.SubscriberAddress">
            <summary>
            Specifies the globally addressable queue address of the subscriber to remove for the given topic
            </summary>
        </member>
        <member name="P:Rebus.Messages.Control.UnsubscribeRequest.Topic">
            <summary>
            Specifis the topic from which the subscriber wishes to unsubscribe
            </summary>
        </member>
        <member name="T:Rebus.Messages.Headers">
            <summary>
            Contains keys of headers known &amp; used by Rebus
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.MessageId">
            <summary>
            Id of the message. Either set the ID explicitly when sending a message, or Rebus will assign one to the message.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Type">
            <summary>
            .NET type (if possible) of the sent message 
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.CorrelationId">
            <summary>
            Any messages sent/forwarded/replied/published while handling a message will get the correlation ID (or the message ID
            if there's no correlation ID) of the handled message copied to it. When a message is initially sent, its correlation ID
            will be its own message ID.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.CorrelationSequence">
            <summary>
            Any messages sent/forwarded/replied/published while handling a message will get a correlation sequence number of the handled message 
            incremented by 1 copied to it. When a message is initially sent, its correlation sequence number is 0. The sequence number
            can be used to deduce a strict ordering of correlated messages, even in the face of clock skew among servers
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ReturnAddress">
            <summary>
            The return address of the message, i.e. the address that repliers must reply to.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ContentType">
            <summary>
            Describes the contents of the message with a type and an encoding
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ContentEncoding">
            <summary>
            Optional header element that specifies an encoding that the content is encoded with, e.g. gzip
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.ErrorDetails">
            <summary>
            Details that can be attached to a message that is forwarded after it has failed
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.SourceQueue">
            <summary>
            Source queue of a message the has bee forwarded to an error queue after it has failed
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.DeferredUntil">
            <summary>
            Indicates that the message must not be consumed right away, delivery should be delayed until the specified time
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.DeferredRecipient">
            <summary>
            Indicates to which input queue the deferred message must be delivered back to
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.TimeToBeReceived">
            <summary>
            Indicates a time span (as a string, on the form hh:MM:ss) after which the queueing system can safely delete the message and thus never deliver it
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Express">
            <summary>
            Header that indicates that the queueing system can trade reliability for performance in order to deliver this message as fast as possible
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.SentTime">
            <summary>
            Headers with <see cref="T:System.DateTimeOffset"/> (serialized with the format string 'O') of the time when the message was sent.
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.Intent">
            <summary>
            Header that indicates whether this message was sent or published
            </summary>
        </member>
        <member name="T:Rebus.Messages.Headers.IntentOptions">
            <summary>
            Contains the possible values for the <see cref="F:Rebus.Messages.Headers.Intent"/> header
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.IntentOptions.PointToPoint">
            <summary>
            This value indicates that the message was sent to one specific recipient, i.e. either by sending or replying
            </summary>
        </member>
        <member name="F:Rebus.Messages.Headers.IntentOptions.PublishSubscribe">
            <summary>
            This value indicates that the message was published to zero or more recipients, i.e. it might not actually be received by anyone.
            When auditing is enabled, a copy is always stored of published messages, regardless of the number of recipients.
            </summary>
        </member>
        <member name="T:Rebus.Messages.TransportMessage">
            <summary>
            Transport message wrapper that has a set of headers and a stream of raw data to be sent/received
            </summary>
        </member>
        <member name="M:Rebus.Messages.TransportMessage.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Constructs the transport message with the given headers, wrapping the given body payload
            </summary>
        </member>
        <member name="P:Rebus.Messages.TransportMessage.Headers">
            <summary>
            Gets the headers of this message
            </summary>
        </member>
        <member name="P:Rebus.Messages.TransportMessage.Body">
            <summary>
            Gets the wrapped body data of this message
            </summary>
        </member>
        <member name="T:Rebus.Messages.Message">
            <summary>
            Logical message wrapper that has a set of headers and a .NET object
            </summary>
        </member>
        <member name="M:Rebus.Messages.Message.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Object)">
            <summary>
            Constructs the message with the specified headers, wrapping the given .NET object as the message body
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Headers">
            <summary>
            Gets the headers of this message
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Body">
            <summary>
            Gets the wrapped body object of this message
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage"/> that writes saga data snapshots as JSON text to a directory in the file system
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the snapshot storage which will write saga data snapshots to files using file names on the form "ID-REVISION.json"
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.Initialize">
            <summary>
            Initializes the file system-based saga snapshot storage by ensuring that the snapshot directory exists and
            making sure that it's writable
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves a snapshot of the saga data along with the given metadata
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorageConfigurationExtensions">
            <summary>
            Configuration extensions for the <see cref="T:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorageConfigurationExtensions.UseJsonFile(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.String)">
            <summary>
            Configures Rebus to use JSON files to store snapshots of saga data
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FilesystemSagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that uses the file system to store data
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FilesystemSagaStorage.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the saga storage using the given <paramref name="basePath"/> 
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FilesystemSagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Looks up an existing saga data instance from the index file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FilesystemSagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Inserts the given saga data instance into the index file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FilesystemSagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the given saga data instance in the index file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FilesystemSagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Removes the saga data instance from the index file
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FileSystemSagaStorageConfigurationExtensions">
            <summary>
            Configures extensions for using the filesystem to store sagas
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FileSystemSagaStorageConfigurationExtensions.UseFilesystem(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.String)">
            <summary>
            Configures Rebus to use the filesystem to store sagas. Please note that this way of storing saga data is not
            the most effective, and therefore it is probably best suited for testing and very simple and mild requirements
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FilesystemTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that stores timeouts in the filesystem
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FilesystemTimeoutManager.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the timeout manager, storing timeouts in the given <paramref name="basePath"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FilesystemTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Stores the message to be retrieved later
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FilesystemTimeoutManager.GetDueMessages">
            <summary>
            Gets all messages that are due at this instant
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.FilesystemTimeoutStorageConfigurationExtensions">
            <summary>
            Configures the bus to use the filesystem to store timeouts
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.FilesystemTimeoutStorageConfigurationExtensions.UseFilesystem(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.String)">
            <summary>
            Configures the bus to use the filesystem to store timeouts
            </summary>
            <param name="configurer">the rebus configuration</param>
            <param name="basePath">the path to store timeouts under</param>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that stores subscriptions in a JSON file. Access to the file is synchronized within the process with a <see cref="T:System.Threading.ReaderWriterLockSlim"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs the subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all subscribers of the given topic from the JSON file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Adds the subscriber to the list of subscribers from the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Removes the subscriber from the list of subscribers of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.IsCentralized">
            <summary>
            Gets whether this subscription storage is centralized (which it shouldn't be - that would probably cause some pretty nasty locking exceptions!)
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage.Dispose">
            <summary>
            Disposes the <see cref="T:System.Threading.ReaderWriterLockSlim"/> that guards access to the file
            </summary>
        </member>
        <member name="T:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorageConfigurationExtensions">
            <summary>
            Configurations extensions for configuring Rebus to use a JSON file as the subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.FileSystem.JsonFileSubscriptionStorageConfigurationExtensions.UseJsonFile(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.String)">
            <summary>
            Configures Rebus to use a JSON file as the subscription storage
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySubscriberStore">
            <summary>
            In-mem subscriber store that can be shared among multiple endpoints to emulate a shared subscription storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriberStore.GetSubscribers(System.String)">
            <summary>
            Gets the subscribers for the current topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriberStore.AddSubscriber(System.String,System.String)">
            <summary>
            Adds the subscriber with the given <paramref name="subscriberAddress"/> to the list of subscribers for the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriberStore.RemoveSubscriber(System.String,System.String)">
            <summary>
            Removes the subscriber with the given <paramref name="subscriberAddress"/> from the list of subscribers for the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySubscriptionStorageExtensions">
            <summary>
            Configuration extensions for in-mem subscriptionstorage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorageExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},Rebus.Persistence.InMem.InMemorySubscriberStore)">
            <summary>
            Configures Rebus to store subscriptions in memory. The subscription storage is assumed to be CENTRALIZED
            with this overload because a <see cref="T:Rebus.Persistence.InMem.InMemorySubscriberStore"/> is passed in.  PLEASE NOTE that this 
            is probably not useful for any other scenario  than TESTING because usually you want subscriptions to be PERSISTENT.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorageExtensions.StoreInMemory(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage})">
            <summary>
            Configures Rebus to store subscriptions in memory. The subscription storage is assumed to be DECENTRALIZED
            with this overload because NO <see cref="T:Rebus.Persistence.InMem.InMemorySubscriberStore"/> is passed in and subscriptions are therefore private
            for this endpoint.  PLEASE NOTE that this  is probably not useful for any other scenario  than TESTING because usually you want 
            subscriptions to be PERSISTENT.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that "persists" saga data in memory. Saga data is serialized/deserialized using Newtonsoft JSON.NET
            with some pretty robust settings, so inheritance and interfaces etc. can be used in the saga data.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Looks up an existing saga data of the given type with a property of the specified name and the specified value
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Saves the given saga data, throwing an exception if the instance already exists
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the saga data
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the given saga data
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemorySubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that "persists" subscriptions in memory.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.#ctor">
            <summary>
            Creates the in-mem subscription storage as a decentralized subscription storage with its
            own private subscriber store
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.#ctor(Rebus.Persistence.InMem.InMemorySubscriberStore)">
            <summary>
            Creates the in-mem subscription storage as a centralized subscription storage, using the given
            <see cref="T:Rebus.Persistence.InMem.InMemorySubscriberStore"/> to share subscriptions
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemorySubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemorySubscriptionStorage.IsCentralized">
            <summary>
            Gets whether the subscription storage is centralized and thus supports bypassing the usual subscription request
            (in a fully distributed architecture, a subscription is established by sending a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            to the owner of a given topic, who then remembers the subscriber somehow - if the subscription storage is
            centralized, the message exchange can be bypassed, and the subscription can be established directly by
            having the subscriber register itself)
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemoryTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that "persists" timeouts in memory.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Stores the message with the given headers and body data, delaying it until the specified <paramref name="approximateDueTime"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.GetDueMessages">
            <summary>
            Gets due messages as of now, given the approximate due time that they were stored with when <see cref="M:Rebus.Timeouts.ITimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])"/> was called
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage">
            <summary>
            Represents a message whose delivery has been deferred into the future
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage.DueTime">
            <summary>
            Gets the time of when delivery of this message is due
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage.Headers">
            <summary>
            Gets the message's headers
            </summary>
        </member>
        <member name="P:Rebus.Persistence.InMem.InMemoryTimeoutManager.DeferredMessage.Body">
            <summary>
            Gets the message's body
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMem.InMemoryTimeoutManager.GetEnumerator">
            <summary>
            Gets an enumerator that allows for iterating through all stored deferred messages
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.DbConnectionFactoryProvider">
            <summary>
            Implementation of <see cref="T:Rebus.Persistence.SqlServer.IDbConnectionProvider"/> that ensures that MARS (multiple active result sets) is enabled on the
            given connection string (possibly by enabling it by itself)
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionFactoryProvider.#ctor(System.Func{System.Threading.Tasks.Task{Rebus.Persistence.SqlServer.IDbConnection}},Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Uses provided SqlConnection factory as constructor for SqlConnection used. Will use <see cref="F:System.Data.IsolationLevel.ReadCommitted"/> by default on transactions,
            unless another isolation level is set with the <see cref="P:Rebus.Persistence.SqlServer.DbConnectionFactoryProvider.IsolationLevel"/> property
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionFactoryProvider.GetConnection">
            <summary>
            Gets a nice ready-to-use database connection with an open transaction
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.DbConnectionFactoryProvider.IsolationLevel">
            <summary>
            Gets/sets the isolation level used for transactions
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerSagaSnapshotStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Auditing.Sagas.ISagaSnapshotStorage"/> that uses a table in SQL Server to store saga snapshots
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaSnapshotStorage.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the snapshot storage
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaSnapshotStorage.EnsureTableIsCreated">
            <summary>
            Creates the subscriptions table if necessary
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaSnapshotStorage.Save(Rebus.Sagas.ISagaData,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Saves a snapshot of the saga data along with the given metadata
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.DbConnectionWrapper">
            <summary>
            Wrapper of <see cref="T:System.Data.SqlClient.SqlConnection"/> that allows for either handling <see cref="T:System.Data.SqlClient.SqlTransaction"/> automatically, or for handling it externally
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.#ctor(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction,System.Boolean)">
            <summary>
            Constructs the wrapper, wrapping the given connection and transaction. It must be indicated with <paramref name="managedExternally"/> whether this wrapper
            should commit/rollback the transaction (depending on whether <see cref="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Complete"/> is called before <see cref="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Dispose"/>), or if the transaction
            is handled outside of the wrapper
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.CreateCommand">
            <summary>
            Creates a ready to used <see cref="T:System.Data.SqlClient.SqlCommand"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.GetTableNames">
            <summary>
            Gets the names of all the tables in the current database for the current schema
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.GetColumns(System.String)">
            <summary>
            Gets information about the columns in the table given by <paramref name="dataTableName"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Complete">
            <summary>
            Marks that all work has been successfully done and the <see cref="T:System.Data.SqlClient.SqlConnection"/> may have its transaction committed or whatever is natural to do at this time
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Dispose">
            <summary>
            Finishes the transaction and disposes the connection in order to return it to the connection pool. If the transaction
            has not been committed (by calling <see cref="M:Rebus.Persistence.SqlServer.DbConnectionWrapper.Complete"/>), the transaction will be rolled back.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.IDbConnection">
            <summary>
            Wrapper of <see cref="T:System.Data.SqlClient.SqlConnection"/> that allows for easily changing how transactions are handled, and possibly how <see cref="T:System.Data.SqlClient.SqlConnection"/> instances
            are reused by various services
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.IDbConnection.CreateCommand">
            <summary>
            Creates a ready to used <see cref="T:System.Data.SqlClient.SqlCommand"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.IDbConnection.GetTableNames">
            <summary>
            Gets the names of all the tables in the current database for the current schema
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.IDbConnection.Complete">
            <summary>
            Marks that all work has been successfully done and the <see cref="T:System.Data.SqlClient.SqlConnection"/> may have its transaction committed or whatever is natural to do at this time
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.IDbConnection.GetColumns(System.String)">
            <summary>
            Gets information about the columns in the table given by <paramref name="dataTableName"/>
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.DbColumn">
            <summary>
            Represents a SQL Server column
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.DbColumn.Name">
            <summary>
            Gets the name of the column
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.DbColumn.Type">
            <summary>
            Gets the SQL datatype of the column
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbColumn.#ctor(System.String,System.Data.SqlDbType)">
            <summary>
            Creates the column
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.IDbConnectionProvider">
            <summary>
            SQL Server database connection provider that allows for easily changing how the current <see cref="T:System.Data.SqlClient.SqlConnection"/> is obtained,
            possibly also changing how transactions are handled
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.IDbConnectionProvider.GetConnection">
            <summary>
            Gets a wrapper with the current <see cref="T:System.Data.SqlClient.SqlConnection"/> inside
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.DbConnectionProvider">
            <summary>
            Implementation of <see cref="T:Rebus.Persistence.SqlServer.IDbConnectionProvider"/> that ensures that MARS (multiple active result sets) is enabled on the
            given connection string (possibly by enabling it by itself)
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionProvider.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Wraps the connection string with the given name from app.config (if it is found), or interprets the given string as
            a connection string to use. Will use <see cref="F:System.Data.IsolationLevel.ReadCommitted"/> by default on transactions,
            unless another isolation level is set with the <see cref="P:Rebus.Persistence.SqlServer.DbConnectionProvider.IsolationLevel"/> property
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.DbConnectionProvider.GetConnection">
            <summary>
            Gets a nice ready-to-use database connection with an open transaction
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.DbConnectionProvider.IsolationLevel">
            <summary>
            Gets/sets the isolation level used for transactions
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerMagic">
            <summary>
            Wraps some nice extension methods for <see cref="T:System.Data.SqlClient.SqlConnection"/> that makes it easy e.g. to query the schema
            </summary>
        </member>
        <member name="F:Rebus.Persistence.SqlServer.SqlServerMagic.PrimaryKeyViolationNumber">
            <summary>
            Error code that is emitted on PK violations
            </summary>
        </member>
        <member name="F:Rebus.Persistence.SqlServer.SqlServerMagic.ObjectDoesNotExistOrNoPermission">
            <summary>
            Error code that is emitted when something does not exist or the login's permissions do not allow the client to see it
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerMagic.GetTableNames(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all tables in the current database
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerMagic.GetIndexNames(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all indexes in the current database
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerMagic.GetColumns(System.Data.SqlClient.SqlConnection,System.String,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all tables in the current database
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerMagic.GetDatabaseNames(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Gets the names of all databases on the current server
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions">
            <summary>
            Configuration extensions for configuring SQL persistence for sagas, subscriptions, and timeouts.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.String,System.String,System.Boolean)">
            <summary>
            Configures Rebus to store saga snapshots in SQL Server
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Auditing.Sagas.ISagaSnapshotStorage},System.Func{System.Threading.Tasks.Task{Rebus.Persistence.SqlServer.IDbConnection}},System.String,System.Boolean)">
            <summary>
            Configures Rebus to store saga snapshots in SQL Server
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.String,System.String,System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store sagas, using the tables specified to store data and indexed properties respectively.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Sagas.ISagaStorage},System.Func{System.Threading.Tasks.Task{Rebus.Persistence.SqlServer.IDbConnection}},System.String,System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store sagas, using the tables specified to store data and indexed properties respectively.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store subscriptions. Use <paramref name="isCentralized"/> = true to indicate whether it's OK to short-circuit
            subscribing and unsubscribing by manipulating the subscription directly from the subscriber or just let it default to false to preserve the
            default behavior.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Subscriptions.ISubscriptionStorage},System.Func{System.Threading.Tasks.Task{Rebus.Persistence.SqlServer.IDbConnection}},System.String,System.Boolean,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store subscriptions. Use <paramref name="isCentralized"/> = true to indicate whether it's OK to short-circuit
            subscribing and unsubscribing by manipulating the subscription directly from the subscriber or just let it default to false to preserve the
            default behavior.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.String,System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store timeouts.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerPersistenceConfigurationExtensions.StoreInSqlServer(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.Func{System.Threading.Tasks.Task{Rebus.Persistence.SqlServer.IDbConnection}},System.String,System.Boolean)">
            <summary>
            Configures Rebus to use SQL Server to store timeouts.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerSagaStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Sagas.ISagaStorage"/> that persists saga data as a Newtonsoft JSON.NET-serialized object to a table in SQL Server.
            Correlation properties are stored in a separate index table, allowing for looking up saga data instanes based on the configured correlation
            properties
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the saga storage, using the specified connection provider and tables for persistence.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.Initialize">
            <summary>
            Initializes the storage by performing a check on the schema to see whether we should use
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.EnsureTablesAreCreated">
            <summary>
            Checks to see if the configured tables exist, creating them if necessary
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Queries the saga index for an instance with the given <paramref name="sagaDataType"/> with a
            a property named <paramref name="propertyName"/> and the value <paramref name="propertyValue"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Serializes the given <see cref="T:Rebus.Sagas.ISagaData"/> and generates entries in the index for the specified <paramref name="correlationProperties"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the given <see cref="T:Rebus.Sagas.ISagaData"/> and generates entries in the index for the specified <paramref name="correlationProperties"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the given <see cref="T:Rebus.Sagas.ISagaData"/> and removes all its entries in the index
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.Subscriptions.ISubscriptionStorage"/> that persists subscriptions in a table in SQL Server
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,System.Boolean,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the storage using the specified connection provider and table to store its subscriptions. If the subscription
            storage is shared by all subscribers and publishers, the <paramref name="isCentralized"/> parameter can be set to true
            in order to subscribe/unsubscribe directly instead of sending subscription/unsubscription requests
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.EnsureTableIsCreated">
            <summary>
            Creates the subscriptions table if necessary
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given <paramref name="topic"/>
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.IsCentralized">
            <summary>
            Gets whether this subscription storage is centralized
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerTimeoutManager">
            <summary>
            Implementation of <see cref="T:Rebus.Timeouts.ITimeoutManager"/> that uses SQL Server to store messages until it's time to deliver them.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutManager.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the timeout manager, using the specified connection provider and table to store the messages until they're due.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutManager.EnsureTableIsCreated">
            <summary>
            Creates the due messages table if necessary
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Defers the message to the time specified by <paramref name="approximateDueTime"/> at which point in time the message will be
            returned to whoever calls <see cref="M:Rebus.Persistence.SqlServer.SqlServerTimeoutManager.GetDueMessages"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutManager.GetDueMessages">
            <summary>
            Gets messages due for delivery at the current time
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineMessageContextExtensions">
            <summary>
            Extensions for the message context 
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineMessageContextExtensions.AbortDispatch(Rebus.Pipeline.IMessageContext)">
            <summary>
            Aborts the current message processing pipeline by making the currently executing handler the last one.
            This means that any message handlers following the current one in the current pipeline will NOT be executed.
            If no errors occurred, the queue transaction will be committed as if everything is allright.
            This method can be used to ABORT message process to allow for a handler to FUNCTION AS A FILTER.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepRemover">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can remove steps based on a predicate
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the pipeline step remover, wrapping the given pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.SendPipeline">
            <summary>
            Gets the outgoing steps from the wrapped pipeline, unless those where one of the registered outgoing step predicates match
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.ReceivePipeline">
            <summary>
            Gets the incoming steps from the wrapped pipeline, unless those where one of the registered incoming step predicates match
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.RemoveIncomingStep(System.Func{Rebus.Pipeline.IIncomingStep,System.Boolean})">
            <summary>
            Adds the predicate, causing matching incoming steps to be removed from the pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepRemover.RemoveOutgoingStep(System.Func{Rebus.Pipeline.IOutgoingStep,System.Boolean})">
            <summary>
            Adds the predicate, causing matching outgoing steps to be removed from the pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvoker">
            <summary>
            Wrapper of the handler that is ready to invoke
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.CanBeInitiatedBy(System.Type)">
            <summary>
            Gets whether a message of the given type is allowed to cause a new saga data instance to be created
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.Receive.HandlerInvoker.CurrentHandlerInvokerItemsKey">
            <summary>
            Key under which the handler invoker will stash itself in the <see cref="P:Rebus.Transport.ITransactionContext.Items"/>
            during the invocation of the wrapped handler
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.Invoke">
            <summary>
            Method to call in order to invoke this particular handler
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.HasSaga">
            <summary>
            Gets whether this invoker's handler is a saga
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.Saga">
            <summary>
            Gets this invoker's handler as a saga (throws if it's not a saga)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.SetSagaData(Rebus.Sagas.ISagaData)">
            <summary>
            Adds to the invoker a piece of saga data that has been determined to be relevant for the invocation
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.GetSagaData">
            <summary>
            Gets from the invoker the piece of saga data that has been determined to be relevant for the invocation, returning null if no such saga data has been set
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker.SkipInvocation">
            <summary>
            Marks this handler as one to skip, i.e. calling this method will make the invoker ignore the call to <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker.Invoke"/>
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker.Handler">
            <summary>
            Gets the contained handler object (which is probably an implementation of <see cref="T:Rebus.Handlers.IHandleMessages"/>, but you should
            not depend on it!)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvoker`1">
            <summary>
            Derivation of the <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> that has the message type
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.#ctor(System.String,System.Func{System.Threading.Tasks.Task},System.Object,Rebus.Transport.ITransactionContext)">
            <summary>
            Constructs the invoker
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Handler">
            <summary>
            Gets the contained handler object
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.HasSaga">
            <summary>
            Gets whther the contained handler object has a saga
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Saga">
            <summary>
            If <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.HasSaga"/> returned true, the <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Handler"/> can be retrieved as a <see cref="P:Rebus.Pipeline.Receive.HandlerInvoker`1.Saga"/> here
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.Invoke">
            <summary>
            Invokes the handler within this handler invoker
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SetSagaData(Rebus.Sagas.ISagaData)">
            <summary>
            Sets a saga instance on the handler
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.GetSagaData">
            <summary>
            Gets the saga data (if any) that was previously set with <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SetSagaData(Rebus.Sagas.ISagaData)"/>. Returns null
            if none has been set
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvoker`1.SkipInvocation">
            <summary>
            Marks this handler invoker to skip its invocation, causing it to do nothin when <see cref="M:Rebus.Pipeline.Receive.HandlerInvoker`1.Invoke"/> is called
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandlerInvokers">
            <summary>
            Represents a sequence of handler invokers
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvokers.#ctor(System.Collections.Generic.IEnumerable{Rebus.Pipeline.Receive.HandlerInvoker})">
            <summary>
            Constructs the sequence
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandlerInvokers.GetEnumerator">
            <summary>
            Gets all the <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/>s that this <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/> contains
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.ActivateHandlersStep">
            <summary>
            Incoming message step that gets relevant handlers for the message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.ActivateHandlersStep.#ctor(Rebus.Activation.IHandlerActivator)">
            <summary>
            Constructs the step with the <see cref="T:Rebus.Activation.IHandlerActivator"/> to use to get the handler instances
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.ActivateHandlersStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Looks up handlers for the incoming message and saves the handlers (without invoking them) to the context as a <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/>
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.HandleDeferredMessagesStep">
            <summary>
            Incoming step that checks for the presence of the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header, using a
            <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to handle the deferral if necessary.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.#ctor(Rebus.Timeouts.ITimeoutManager,Rebus.Transport.ITransport,Rebus.Config.Options,Rebus.Logging.IRebusLoggerFactory,Rebus.Threading.IAsyncTaskFactory)">
            <summary>
            Constructs the step, using the specified <see cref="T:Rebus.Timeouts.ITimeoutManager"/> to defer relevant messages
            and the specified <see cref="T:Rebus.Transport.ITransport"/> to deliver messages when they're due.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Initialize">
            <summary>
            Initialized the step (starts the <see cref="F:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.DueMessagesSenderTaskName"/> background task if using the internal timeout manager)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Checks to see if the incoming message has the <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header. If that is the case, the message is either stored for later delivery
            or forwarded to the configured external timeout manager. If not, the message will be passed on down the pipeline.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.HandleDeferredMessagesStep.Dispose">
            <summary>
            Last-resort disposal of the due messages background task
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep">
            <summary>
            Incoming step that gets the current <see cref="T:Rebus.Messages.TransportMessage"/> from the context and deserializes its body,
            saving the result as a <see cref="T:Rebus.Messages.Message"/> back to the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep.#ctor(Rebus.Serialization.ISerializer)">
            <summary>
            Constructs the step, using the specified serializer to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DeserializeIncomingMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Deserializes the incoming message by invoking the currently configured <see cref="T:Rebus.Serialization.ISerializer"/> on the <see cref="T:Rebus.Messages.TransportMessage"/> found in the context,
            storing the result as the <see cref="T:Rebus.Messages.Message"/> returned by the serializer
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Receive.DispatchIncomingMessageStep">
            <summary>
            Incoming step that gets a <see cref="T:System.Collections.Generic.List`1"/> where T is <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> from the context
            and invokes them in the order they're in.
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.Receive.DispatchIncomingMessageStep.AbortDispatchContextKey">
            <summary>
            Keys of an <see cref="T:Rebus.Pipeline.IncomingStepContext"/> items that indicates that message dispatch must be stopped
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Receive.DispatchIncomingMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Processes the message
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignTypeHeaderStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.Type"/> header of the outgoing message, unless it has already been set.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignTypeHeaderStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.Type"/> to the simple assembly-qualified type name of the sent object, unless
            the header has not already been added
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AutoHeadersOutgoingStep">
            <summary>
            Outgoing step that picks up <see cref="T:Rebus.Messages.HeaderAttribute"/> from the message type, automatically adding headers
            with <see cref="P:Rebus.Messages.HeaderAttribute.Key"/> set to <see cref="P:Rebus.Messages.HeaderAttribute.Value"/> if a header with such key has not already been added.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AutoHeadersOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out the auto-header logic
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignDateTimeOffsetHeader">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.SentTime"/> header of the outgoing message to <see cref="P:Rebus.Time.RebusTime.Now"/>
            (serializing it with the "O" format, i.e. its ISO 8601 representation)
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignDateTimeOffsetHeader.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.SentTime"/> header
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.DestinationAddresses">
            <summary>
            Encapsulates a list of destination addresses
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.DestinationAddresses.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs the list of destination addresses
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.DestinationAddresses.GetEnumerator">
            <summary>
            Gets all the addresses that this <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> object contains
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.ValidateOutgoingMessageStep">
            <summary>
            Outgoing message step that checks the consistency of the message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.ValidateOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the step
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.FlowCorrelationIdStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.CorrelationId"/> header of the outgoing message if it has not already been set.
            The value used is one of the following (in prioritized order):
            1) The correlation ID of the message currently being handled,
            2) The message ID of the message currently being handled,
            3) The message's own message ID
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.FlowCorrelationIdStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Flows the correlation ID like it should
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.SendOutgoingMessageStep">
            <summary>
            Outgoing step that uses the current transport to send the <see cref="T:Rebus.Messages.TransportMessage"/>
            found in the context to the destination address specified by looking up
            <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> in the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SendOutgoingMessageStep.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step, using the specified transport to send the messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SendOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sends the outgoing message using the configured <see cref="T:Rebus.Transport.ITransport"/>, sending to the <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/>
            found in the <see cref="T:Rebus.Pipeline.OutgoingStepContext"/>.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.SerializeOutgoingMessageStep">
            <summary>
            Outgoing step that gets the current <see cref="T:Rebus.Messages.Message"/> from the context and serializes its body,
            saving the result as a <see cref="T:Rebus.Messages.TransportMessage"/> back to the context.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SerializeOutgoingMessageStep.#ctor(Rebus.Serialization.ISerializer)">
            <summary>
            Constructs the step, using the specified serializer to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.SerializeOutgoingMessageStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Serializes the outgoing message by invoking the currently configured <see cref="T:Rebus.Serialization.ISerializer"/> on the <see cref="T:Rebus.Messages.Message"/> found in the context,
            storing the result as the <see cref="T:Rebus.Messages.TransportMessage"/> returned by the serializer
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignGuidMessageIdStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.MessageId"/> header of the outgoing message, unless it has already been set.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignGuidMessageIdStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Sets the <see cref="F:Rebus.Messages.Headers.MessageId"/>. The message ID is a new <see cref="T:System.Guid"/>
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.Send.AssignReturnAddressStep">
            <summary>
            Outgoing step that sets the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header of the outgoing message to the input queue
            address (found with <see cref="P:Rebus.Transport.ITransport.Address"/>), unless the header has already been set to something else.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignReturnAddressStep.#ctor(Rebus.Transport.ITransport)">
            <summary>
            Constructs the step, getting the input queue address from the given <see cref="T:Rebus.Transport.ITransport"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.Send.AssignReturnAddressStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            If no return address has been added to the message, the sender's input queue address is automatically added as the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/>
            header
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineAbsolutePosition">
            <summary>
            Indicates an absolute position in the pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineAbsolutePosition.Front">
            <summary>
            Denotes the front of the pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineAbsolutePosition.Back">
            <summary>
            Denotes the back of the pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineCache">
            <summary>
            Cache that can be used as the outermost decorator in order to avoid contantly running any pipeline step injection logic
            that might be configured
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepConcatenator">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can concatenate steps to either pipeline at the front or at the back
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the concatenator
            </summary>
            <param name="pipeline"></param>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.OnSend(Rebus.Pipeline.IOutgoingStep,Rebus.Pipeline.PipelineAbsolutePosition)">
            <summary>
            Sets the specified outgoing <paramref name="step"/> to be concatenated at the position specified by <paramref name="position"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.OnReceive(Rebus.Pipeline.IIncomingStep,Rebus.Pipeline.PipelineAbsolutePosition)">
            <summary>
            Sets the specified receive <paramref name="step"/> to be concatenated at the position specified by <paramref name="position"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.SendPipeline">
            <summary>
            Gets the send pipeline with front and back steps concatenated
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepConcatenator.ReceivePipeline">
            <summary>
            Gets the receive pipeline with front and back steps concatenated
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineStepInjector">
            <summary>
            Decorator of <see cref="T:Rebus.Pipeline.IPipeline"/> that can inject one or more steps into either pipeline,
            positionint the injected steps relatively to another step by its type.
            Could probably be extended with more ways of detecting "the other step" than by its concrete type.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.#ctor(Rebus.Pipeline.IPipeline)">
            <summary>
            Constructs the step injector, wrapping the given <see cref="T:Rebus.Pipeline.IPipeline"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.SendPipeline">
            <summary>
            Gets the ordered sequence of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> that makes up the outgoing pipeline, injecting any configured outgoing steps
            at their appropriate places
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.ReceivePipeline">
            <summary>
            Gets the ordered sequence of <see cref="T:Rebus.Pipeline.IIncomingStep"/> that makes up the incoming pipeline, injecting any configured incoming steps
            at their appropriate places
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.OnSend(Rebus.Pipeline.IOutgoingStep,Rebus.Pipeline.PipelineRelativePosition,System.Type)">
            <summary>
            Configures injection of the given <see cref="T:Rebus.Pipeline.IOutgoingStep"/>, positioning it relative to another step
            specified by <paramref name="anchorStep"/>. The relative position is specified with either
            <see cref="F:Rebus.Pipeline.PipelineRelativePosition.Before"/> or <see cref="F:Rebus.Pipeline.PipelineRelativePosition.After"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.PipelineStepInjector.OnReceive(Rebus.Pipeline.IIncomingStep,Rebus.Pipeline.PipelineRelativePosition,System.Type)">
            <summary>
            Configures injection of the given <see cref="T:Rebus.Pipeline.IIncomingStep"/>, positioning it relative to another step
            specified by <paramref name="anchorStep"/>. The relative position is specified with either
            <see cref="F:Rebus.Pipeline.PipelineRelativePosition.Before"/> or <see cref="F:Rebus.Pipeline.PipelineRelativePosition.After"/>
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.PipelineRelativePosition">
            <summary>
            Indicates in which way a position is related to another step
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineRelativePosition.Before">
            <summary>
            Indicates that the step must be positioned before the other step
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.PipelineRelativePosition.After">
            <summary>
            Indicates that the step must be positioned after the other step
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IIncomingStep">
            <summary>
            Represents a step that will have its <see cref="M:Rebus.Pipeline.IIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})"/> method called for each incoming message to be handled.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the incoming message :)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IMessageContext">
            <summary>
            Representation of the current "message context", which is a convenience wrapper that gives access to the current <see cref="T:Rebus.Transport.ITransactionContext"/>
            (which is the outermost context, the one that spans the entire queue receive transaction) and the current
            <see cref="P:Rebus.Pipeline.IMessageContext.IncomingStepContext"/> (which is actually contained in the transaction context).
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.TransactionContext">
            <summary>
            This is the outermost context, the one that spans the entire queue receive transaction. The other properties on the message
            context are merely provided as a convenience.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.IncomingStepContext">
            <summary>
            Gets the step context, i.e. the context that is passed down through the step pipeline when a message is received.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.TransportMessage">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.TransportMessage"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.Message">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.Message"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.IMessageContext.Headers">
            <summary>
            Gets the headers dictionary of the incoming message (same as accessing the Headers of the context's transport message,
            or the logical message if the message has been properly deserialized)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IncomingStepContext">
            <summary>
            Concrete derivation of <see cref="T:Rebus.Pipeline.StepContext"/> that is meant to be used to pass down the pipeline for processing incoming messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IncomingStepContext.#ctor(Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Constructs the step context, initially stashing the given <see cref="T:Rebus.Messages.TransportMessage"/> and <see cref="T:Rebus.Transport.ITransactionContext"/> into its bag of objects
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IOutgoingStep">
            <summary>
            Represents a step that will have its <see cref="M:Rebus.Pipeline.IOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})"/> method called for each outgoing message to be sent.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the outgoing message :)
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.MessageContext">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IMessageContext"/> that provides the static gateway <see cref="P:Rebus.Pipeline.MessageContext.Current"/> property to get
            the current message context.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.TransactionContext">
            <summary>
            This is the outermost context, the one that spans the entire queue receive transaction. The other properties on the message
            context are merely provided as a convenience.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.IncomingStepContext">
            <summary>
            Gets the step context, i.e. the context that is passed down through the step pipeline when a message is received.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.TransportMessage">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.TransportMessage"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Message">
            <summary>
            Gets the <see cref="P:Rebus.Pipeline.IMessageContext.Message"/> model for the message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Headers">
            <summary>
            Gets the headers dictionary of the incoming message (same as accessing the Headers of the context's transport message,
            or the logical message if the message has been properly deserialized)
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.MessageContext.Current">
            <summary>
            Gets the current message context from the current <see cref="T:Rebus.Transport.AmbientTransactionContext"/> (accessed by
            <see cref="P:Rebus.Transport.AmbientTransactionContext.Current"/>), returning null if no transaction context was found
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.OutgoingStepContext">
            <summary>
            Concrete derivation of <see cref="T:Rebus.Pipeline.StepContext"/> that is meant to be used to pass down the pipeline for processing outgoing messages
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.OutgoingStepContext.#ctor(Rebus.Messages.Message,Rebus.Transport.ITransactionContext,Rebus.Pipeline.Send.DestinationAddresses)">
            <summary>
            Constructs the step context, initially stashing the given <see cref="T:Rebus.Messages.Message"/>, list of <see cref="T:Rebus.Pipeline.Send.DestinationAddresses"/> and <see cref="T:Rebus.Transport.ITransactionContext"/> into its bag of objects
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.StepContext">
            <summary>
            General step context model that encapsulates an object bag that can be used to pass data from step to step when executing a step pipeline
            </summary>
        </member>
        <member name="F:Rebus.Pipeline.StepContext.StepContextKey">
            <summary>
            Key reserved for the step context when it is inserted into the current <see cref="P:Rebus.Transport.ITransactionContext.Items"/>
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Save``1(``0)">
            <summary>
            Saves the given instance in the bag with a key derived from the (possibly explicitly specified) type <typeparamref name="T"/> (by calling <see cref="P:System.Type.FullName"/>).
            Any instances currently stored under that key will be overwritten.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Save``1(System.String,``0)">
            <summary>
            Saves the given instance in the bag with the specified key. Any instances currently stored under that key will be overwritten.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Load``1">
            <summary>
            Loads the instance stored under the key that is stored under a key as determined by calling <see cref="P:System.Type.FullName"/> on the specified type <typeparamref name="T"/>.
            Returns null if none could be found.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepContext.Load``1(System.String)">
            <summary>
            Loads the instance stored under the specified key. Returns null if none could be found.
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.StepDocumentationAttribute">
            <summary>
            Documents the purpose of an <see cref="T:Rebus.Pipeline.IIncomingStep"/> or <see cref="T:Rebus.Pipeline.IOutgoingStep"/> which can then be used by tools to generate nice docs
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.StepDocumentationAttribute.#ctor(System.String)">
            <summary>
            Creates the attribute with the given documentation test
            </summary>
        </member>
        <member name="P:Rebus.Pipeline.StepDocumentationAttribute.Text">
            <summary>
            Gets the documentation text
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.DefaultPipeline">
            <summary>
            Default pipeline implementation that can be built with a fluent syntax by calling <see cref="M:Rebus.Pipeline.DefaultPipeline.OnSend(Rebus.Pipeline.IOutgoingStep)"/> and <see cref="M:Rebus.Pipeline.DefaultPipeline.OnReceive(Rebus.Pipeline.IIncomingStep)"/> respectively,
            in the order that the steps must be invoked in.
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.SendPipeline">
            <summary>
            Gets the send pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.ReceivePipeline">
            <summary>
            Gets the receive pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.OnReceive(Rebus.Pipeline.IIncomingStep)">
            <summary>
            Adds a new incoming step to the receive pipeline
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipeline.OnSend(Rebus.Pipeline.IOutgoingStep)">
            <summary>
            Adds a new outgoing step to the send pipeline
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IPipelineInvoker">
            <summary>
            The invoker is capable of invoking an ordered pipeline of steps
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipelineInvoker.Invoke(Rebus.Pipeline.IncomingStepContext,System.Collections.Generic.IEnumerable{Rebus.Pipeline.IIncomingStep})">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IIncomingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.IncomingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipelineInvoker.Invoke(Rebus.Pipeline.OutgoingStepContext,System.Collections.Generic.IEnumerable{Rebus.Pipeline.IOutgoingStep})">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.OutgoingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IStep">
            <summary>
            General step interface - allows for treating incoming/outgoing pipeline steps equally in some regards, even though they're different
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.IPipeline">
            <summary>
            Models a pipeline of steps that will be executed for each sent/received message respectively
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipeline.SendPipeline">
            <summary>
            Gets the send pipeline, i.e. the sequence of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> implementations that will be executed for each outgoing message
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.IPipeline.ReceivePipeline">
            <summary>
            Gets the receive pipeline, i.e. the sequence of <see cref="T:Rebus.Pipeline.IIncomingStep"/> implementations that will be executed for each incoming message
            </summary>
        </member>
        <member name="T:Rebus.Pipeline.DefaultPipelineInvoker">
            <summary>
            give me a pipeline and I'll invoke it
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipelineInvoker.Invoke(Rebus.Pipeline.IncomingStepContext,System.Collections.Generic.IEnumerable{Rebus.Pipeline.IIncomingStep})">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IIncomingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.IncomingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="M:Rebus.Pipeline.DefaultPipelineInvoker.Invoke(Rebus.Pipeline.OutgoingStepContext,System.Collections.Generic.IEnumerable{Rebus.Pipeline.IOutgoingStep})">
            <summary>
            Invokes the pipeline of <see cref="T:Rebus.Pipeline.IOutgoingStep"/> steps, passing the given <see cref="T:Rebus.Pipeline.OutgoingStepContext"/> to each step as it is invoked
            </summary>
        </member>
        <member name="T:Rebus.Legacy.LegacySubscriptionMessagesBinder">
            <summary>
            Type binder for JSON.NET that maps old Rebus' SubscriptionMessage to <see cref="T:Rebus.Legacy.LegacySubscriptionMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Legacy.LegacyCompatibilityConfigurationExtensions">
            <summary>
            Configuration extensions for enabling legacy compatibility
            </summary>
        </member>
        <member name="M:Rebus.Legacy.LegacyCompatibilityConfigurationExtensions.EnableLegacyCompatibility(Rebus.Config.OptionsConfigurer)">
            <summary>
            Makes Rebus "legacy compatible", i.e. enables wire-level compatibility with older Rebus versions. WHen this is enabled,
            all endpoints need to be old Rebus endpoints or new Rebus endpoints with this feature enabled
            </summary>
        </member>
        <member name="T:Rebus.Profiling.PipelineStepProfiler">
            <summary>
            Implementation of <see cref="T:Rebus.Pipeline.IPipeline"/> that wraps another <see cref="T:Rebus.Pipeline.IPipeline"/>
            and injects instances of a single step into the pipeline which can be used to measure time spent
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfiler.#ctor(Rebus.Pipeline.IPipeline,Rebus.Profiling.PipelineStepProfilerStats)">
            <summary>
            Creates the profiler
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfiler.SendPipeline">
            <summary>
            Gets the original send pipeline
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfiler.ReceivePipeline">
            <summary>
            Gets a pipeline with time-tracking steps interleaved
            </summary>
        </member>
        <member name="T:Rebus.Profiling.PipelineStepProfilerStats">
            <summary>
            Stats collector
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfilerStats.GetAndResetStats">
            <summary>
            Gets the current stats and resets the collector
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfilerStats.GetStats">
            <summary>
            Gets the current stats
            </summary>
        </member>
        <member name="T:Rebus.Profiling.PipelineStepProfilerStats.StepStat">
            <summary>
            Represents an aggregation of measurements
            </summary>
        </member>
        <member name="P:Rebus.Profiling.PipelineStepProfilerStats.StepStat.StepType">
            <summary>
            Type of step for which this particular statistic was collected
            </summary>
        </member>
        <member name="P:Rebus.Profiling.PipelineStepProfilerStats.StepStat.Elapsed">
            <summary>
            Time spent
            </summary>
        </member>
        <member name="P:Rebus.Profiling.PipelineStepProfilerStats.StepStat.Percentage">
            <summary>
            Gets the percentage of time spent in this particular step
            </summary>
        </member>
        <member name="M:Rebus.Profiling.PipelineStepProfilerStats.StepStat.ToString">
            <summary>
            Gets a string representation of this stat on the form "type: elapsed"
            </summary>
        </member>
        <member name="T:Rebus.Retry.ErrorTracking.InMemErrorTracker">
            <summary>
            Implementation of <see cref="T:Rebus.Retry.IErrorTracker"/> that tracks errors in an in-mem dictionary
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.#ctor(System.Int32,Rebus.Logging.IRebusLoggerFactory,Rebus.Threading.IAsyncTaskFactory)">
            <summary>
            Constructs the in-mem error tracker with the configured number of delivery attempts as the MAX
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.Initialize">
            <summary>
            Initializes the in-mem error tracker - starts a background task that periodically cleans up tracked errors that haven't had any activity for 10 minutes or more
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.RegisterError(System.String,System.Exception)">
            <summary>
            Registers the given <paramref name="exception"/> under the supplied <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.HasFailedTooManyTimes(System.String)">
            <summary>
            Gets whether too many errors have been tracked for the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.GetShortErrorDescription(System.String)">
            <summary>
            Gets a short description of the tracked errors for the given <paramref name="messageId"/> on the form
            "n unhandled exceptions"
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.GetFullErrorDescription(System.String)">
            <summary>
            Gets a long and detailed description of the tracked errors for the given <paramref name="messageId"/>
            consisting of time and full exception details for all registered exceptions
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.GetExceptions(System.String)">
            <summary>
            Gets all caught exceptions for the message ID
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.CleanUp(System.String)">
            <summary>
            Cleans up whichever tracking wr have done for the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Retry.ErrorTracking.InMemErrorTracker.Dispose">
            <summary>
            Stops the periodic cleanup of tracked messages
            </summary>
        </member>
        <member name="T:Rebus.Retry.IErrorHandler">
            <summary>
            Serivce that gets to handle failed messages
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorHandler.HandlePoisonMessage(Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext,System.String)">
            <summary>
            Handles the poisonous message in the right way
            </summary>
        </member>
        <member name="T:Rebus.Retry.IErrorTracker">
            <summary>
            Service that is responsible for tracking errors across message deliveries.
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.RegisterError(System.String,System.Exception)">
            <summary>
            This method is called on each experienced failed delivery
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.CleanUp(System.String)">
            <summary>
            This method is called when there's no need to track the error anymore
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.HasFailedTooManyTimes(System.String)">
            <summary>
            Gets whether the given message ID has had too many error registered for it
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.GetShortErrorDescription(System.String)">
            <summary>
            Should get a short error description for the message ID (i.e. something like "5 failed deliveries")
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.GetFullErrorDescription(System.String)">
            <summary>
            Should get a full, detailed error description for the message ID (i.e. could be timestamps and full stack traces for all failed deliveries)
            </summary>
        </member>
        <member name="M:Rebus.Retry.IErrorTracker.GetExceptions(System.String)">
            <summary>
            Gets all caught exceptions for the message ID
            </summary>
        </member>
        <member name="T:Rebus.Retry.IRetryStrategyStep">
            <summary>
            Special marker for the retry strategy step
            </summary>
        </member>
        <member name="T:Rebus.Retry.PoisonQueues.PoisonQueueErrorHandler">
            <summary>
            Default <see cref="T:Rebus.Retry.IErrorHandler"/> that uses a "poison queue" to function as storage for failed messages.
            </summary>
        </member>
        <member name="M:Rebus.Retry.PoisonQueues.PoisonQueueErrorHandler.#ctor(Rebus.Retry.Simple.SimpleRetryStrategySettings,Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates the error handler
            </summary>
        </member>
        <member name="M:Rebus.Retry.PoisonQueues.PoisonQueueErrorHandler.Initialize">
            <summary>
            Initializes the poison queue error handler by creating the error queue if necessary
            </summary>
        </member>
        <member name="M:Rebus.Retry.PoisonQueues.PoisonQueueErrorHandler.HandlePoisonMessage(Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext,System.String)">
            <summary>
            Handles the poisonous message by forwarding it to the configured error queue
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.FailedMessageWrapper`1">
            <summary>
            Wraps a failed message that is to be retried
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.Message">
            <summary>
            Gets the message that failed
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.ErrorDescription">
            <summary>
            Gets a (sometimes pretty long) description of the encountered error(s)
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.Exceptions">
            <summary>
            Gets all exceptions that were caught leading to this <see cref="T:Rebus.Retry.Simple.IFailed`1"/>
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.FailedMessageWrapper`1.Headers">
            <summary>
            Gets the headers of the message that failed
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.FailedMessageWrapper`1.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},`0,System.String,System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Constructs the wrapper with the given message
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.FailedMessageWrapper`1.ToString">
            <summary>
            Returns a string that represents the current failed message
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.IFailed`1">
            <summary>
            Interface of the wrapper of a failed message
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.Message">
            <summary>
            Gets the message that failed
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.ErrorDescription">
            <summary>
            Gets a (sometimes pretty long) description of the encountered error(s)
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.Headers">
            <summary>
            Gets the headers of the message that failed
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.IFailed`1.Exceptions">
            <summary>
            Gets all exceptions that were caught leading to this failed message
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategyConfigurationExtensions">
            <summary>
            Configuration extensions for the simple retry strategy
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategyConfigurationExtensions.SimpleRetryStrategy(Rebus.Config.OptionsConfigurer,System.String,System.Int32,System.Boolean)">
            <summary>
            Configures the simple retry strategy, using the specified error queue address and number of delivery attempts
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategySettings">
            <summary>
            Contains the settings used by <see cref="T:Rebus.Retry.Simple.SimpleRetryStrategy"/>
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultErrorQueueName">
            <summary>
            Name of the default error queue, which will be used unless <see cref="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.ErrorQueueAddress"/> is set to something else
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultNumberOfDeliveryAttempts">
            <summary>
            Number of delivery attempts that will be used unless <see cref="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.MaxDeliveryAttempts"/> is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategySettings.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            Creates the settings with the given error queue address and number of delivery attempts, defaulting to <see cref="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultErrorQueueName"/> and <see cref="F:Rebus.Retry.Simple.SimpleRetryStrategySettings.DefaultNumberOfDeliveryAttempts"/> 
            as the error queue address and number of delivery attempts, respectively
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.ErrorQueueAddress">
            <summary>
            Name of the error queue
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.MaxDeliveryAttempts">
            <summary>
            Number of attempted deliveries to make before moving the poisonous message to the error queue
            </summary>
        </member>
        <member name="P:Rebus.Retry.Simple.SimpleRetryStrategySettings.SecondLevelRetriesEnabled">
            <summary>
            Configures whether an additional round of delivery attempts should be made with a <see cref="T:Rebus.Retry.Simple.FailedMessageWrapper`1"/> wrapping the originally failed messageS
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategy">
            <summary>
            Implementation of <see cref="T:Rebus.Retry.IRetryStrategy"/> that tracks errors in memory
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategy.#ctor(Rebus.Retry.Simple.SimpleRetryStrategySettings,Rebus.Retry.IErrorTracker,Rebus.Retry.IErrorHandler)">
            <summary>
            Constructs the retry strategy with the given settings, creating an error queue with the configured name if necessary
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategy.GetRetryStep">
            <summary>
            Gets the retry step with appropriate settings for this <see cref="T:Rebus.Retry.Simple.SimpleRetryStrategy"/>
            </summary>
        </member>
        <member name="T:Rebus.Retry.Simple.SimpleRetryStrategyStep">
            <summary>
            Incoming message pipeline step that implements a retry mechanism - if the call to the rest of the pipeline fails,
            the exception is caught and the queue transaction is rolled back. Caught exceptions are tracked in-mem, and after
            a configurable number of retries, the message will be forwarded to the configured error queue and the rest of the pipeline will not be called
            </summary>
        </member>
        <member name="F:Rebus.Retry.Simple.SimpleRetryStrategyStep.DispatchAsFailedMessageKey">
            <summary>
            Key of a step context item that indicates that the message must be wrapped in a <see cref="T:Rebus.Retry.Simple.FailedMessageWrapper`1"/> after being deserialized
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategyStep.#ctor(Rebus.Retry.Simple.SimpleRetryStrategySettings,Rebus.Retry.IErrorTracker,Rebus.Retry.IErrorHandler)">
            <summary>
            Constructs the step, using the given transport and settings
            </summary>
        </member>
        <member name="M:Rebus.Retry.Simple.SimpleRetryStrategyStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the entire message processing pipeline in an exception handler, tracking the number of failed delivery attempts.
            Forwards the message to the error queue when the max number of delivery attempts has been exceeded.
            </summary>
        </member>
        <member name="T:Rebus.Retry.IRetryStrategy">
            <summary>
            Determines the retry strategy by providing an implementation of <see cref="T:Rebus.Retry.IRetryStrategyStep"/> which will be
            put in front of the incoming message pipeline
            </summary>
        </member>
        <member name="M:Rebus.Retry.IRetryStrategy.GetRetryStep">
            <summary>
            Should return a <see cref="T:Rebus.Retry.IRetryStrategyStep"/> which is an <see cref="T:Rebus.Pipeline.IIncomingStep"/> that implements the retry strategy
            </summary>
        </member>
        <member name="T:Rebus.Routing.Exceptions.AutoForwardOnExceptionConfigurationExtensions">
            <summary>
            Configuration extensions for configuring automatic forwarding on certain exception types
            </summary>
        </member>
        <member name="M:Rebus.Routing.Exceptions.AutoForwardOnExceptionConfigurationExtensions.ForwardOnException``1(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter},System.String,Rebus.Logging.LogLevel,System.Func{``0,System.Boolean})">
            <summary>
            Short-circuits the usual retry strategy by immediately forwarding the transport message to the specified queue when an
            exception of the type specified by <typeparamref name="TException"/> is caught. Please note that any outgoing message
            that have already been sent WILL BE SENT because the queue transaction is not rolled back.
            Use <paramref name="logLevel"/> to specify which log level to use when logging the forwarding action.
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.ForwardAction">
            <summary>
            Represents some action to perform with the incoming transport message. Must be created via the static functions
            </summary>
        </member>
        <member name="F:Rebus.Routing.TransportMessages.ForwardAction.None">
            <summary>
            Gets an action that causes the message to be handled normally
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardAction.ForwardTo(System.String)">
            <summary>
            Gets an action that causes the message to be forwarded to the queue specified by <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.ForwardTransportMessageStep">
            <summary>
            Incoming message step that looks at the transport message and possibly forwards it to another queue
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardTransportMessageStep.#ctor(System.Func{Rebus.Messages.TransportMessage,System.Threading.Tasks.Task{Rebus.Routing.TransportMessages.ForwardAction}},Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.ForwardTransportMessageStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Invokes the routing function and performs some action depending on the returned <see cref="T:Rebus.Routing.TransportMessages.ForwardAction"/> result
            </summary>
        </member>
        <member name="T:Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions">
            <summary>
            Configuration extensions for very fast filtering and forwarding of incoming transport messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions.AddTransportMessageForwarder(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter},System.Func{Rebus.Messages.TransportMessage,System.Threading.Tasks.Task{Rebus.Routing.TransportMessages.ForwardAction}})">
            <summary>
            Adds the given routing function - should return <see cref="F:Rebus.Routing.TransportMessages.ForwardAction.None"/> to do nothing, or another action
            available on <see cref="T:Rebus.Routing.TransportMessages.ForwardAction"/> in order to do something to the message
            </summary>
        </member>
        <member name="T:Rebus.Routing.TopicBased.TopicBasedRouter">
            <summary>
            Implementation of <see cref="T:Rebus.Routing.IRouter"/> that uses string-based topics to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouter.Map(System.String,System.String)">
            <summary>
            Maps the specified topic to the specified address
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouter.GetDestinationAddress(Rebus.Messages.Message)">
            <summary>
            Called when sending messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouter.GetOwnerAddress(System.String)">
            <summary>
            Called when subscribing to messages
            </summary>
        </member>
        <member name="T:Rebus.Routing.TopicBased.TopicBasedRouterConfigurationExtensions">
            <summary>
            Router configuration extensions that help with setting up a topic-based routing
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouterConfigurationExtensions.TopicBased(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter})">
            <summary>
            Selects topic-based routing. This simple type of routing can ONLY be used for PUB/SUB and it will go away soon
            </summary>
        </member>
        <member name="T:Rebus.Routing.TopicBased.TopicBasedRouterConfigurationExtensions.TopicBasedRouterConfigurationBuilder">
            <summary>
            Builder that can help with mapping topics to addresses
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouterConfigurationExtensions.TopicBasedRouterConfigurationBuilder.#ctor(Rebus.Routing.TopicBased.TopicBasedRouter)">
            <summary>
            Constructs the builder
            </summary>
        </member>
        <member name="M:Rebus.Routing.TopicBased.TopicBasedRouterConfigurationExtensions.TopicBasedRouterConfigurationBuilder.Map(System.String,System.String)">
            <summary>
            Maps the specified topic to the specified address
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouter">
            <summary>
            Routing logic that maps types to owning endpoints.
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the router
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyOf``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapAssemblyOf(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <paramref name="messageType"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.Map``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <typeparamref name="TMessage"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.MapFallback(System.String)">
            <summary>
            Configures <paramref name="destinationAddress"/> as a fallback which will be returned when trying to get a destination for an unmapped type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.Map(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <paramref name="messageType"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.GetDestinationAddress(Rebus.Messages.Message)">
            <summary>
            Gets the destination address for the given message
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouter.GetOwnerAddress(System.String)">
            <summary>
            Looks up the owner of the topic which is assumed to be an assembly-qualified name of an available .NET type
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions">
            <summary>
            Configuration extensions for configuring type-based routing (i.e. routing where each message type has one, single unambiguous
            owning endpoint)
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBased(Rebus.Config.StandardConfigurer{Rebus.Routing.IRouter})">
            <summary>
            Configures Rebus to use type-based routing
            </summary>
        </member>
        <member name="T:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder">
            <summary>
            Type-based routing configuration builder that can be called fluently to map message types to their owning endpoints
            </summary>
        </member>
        <member name="F:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder._configurationActions">
            <summary>
            We use this way of storing configuration actions in order to preserve the order
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.Map``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <typeparamref name="TMessage"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.Map(System.Type,System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of the <paramref name="messageType"/> message type
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapAssemblyOf``1(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as the owner of all message types found in the same assembly as <typeparamref name="TMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions.TypeBasedRouterConfigurationBuilder.MapFallback(System.String)">
            <summary>
            Maps <paramref name="destinationAddress"/> as a fallback destination to use when none of the configured mappings match
            </summary>
        </member>
        <member name="T:Rebus.Routing.IRouter">
            <summary>
            Abstraction of the routing logic. Should be capable of returning a destination address for a message
            and an owner address for a topic.
            </summary>
        </member>
        <member name="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)">
            <summary>
            Called when sending messages
            </summary>
        </member>
        <member name="M:Rebus.Routing.IRouter.GetOwnerAddress(System.String)">
            <summary>
            Called when subscribing to messages
            </summary>
        </member>
        <member name="T:Rebus.Sagas.IAmInitiatedBy`1">
            <summary>
            Derived marker interface, allowing for a handler to indicate that messages of type <typeparamref name="TMessage"/> 
            are allowed to instantiate new saga instances if the message cannot be correlated with an already existing instance
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotencyData">
            <summary>
            This chunk of data help with tracking handled messages and externally visible behavior (i.e. outbound messages) from handling each message
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotencyData.OutgoingMessages">
            <summary>
            Gets the outgoing messages
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotencyData.HandledMessageIds">
            <summary>
            Getst the IDs of all messages that have been handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.HasAlreadyHandled(System.String)">
            <summary>
            Gets whether the message with the given ID has already been handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.GetOutgoingMessages(System.String)">
            <summary>
            Gets the outgoing messages for the incoming message with the given ID
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.MarkMessageAsHandled(System.String)">
            <summary>
            Marks the message with the given ID as handled
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotencyData.AddOutgoingMessage(System.String,System.Collections.Generic.IEnumerable{System.String},Rebus.Messages.TransportMessage)">
            <summary>
            Adds the <see cref="T:Rebus.Messages.TransportMessage"/> as an outgoing message destined for the addresses specified by <paramref name="destinationAddresses"/>
            under the given <paramref name="messageId"/>
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSaga`1">
            <summary>
            Sagas derived from <see cref="T:Rebus.Sagas.Idempotent.IdempotentSaga`1"/> are sagas that guarantee idempotency by guarding against
            handling the same message twice by tracking IDs of handled messages
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaConfigurationExtensions">
            <summary>
            Configuration extension for the idempotent sagas feature (allows for guaranteeing that a saga instance does not handle the same
            message twice, even in the face of at-least-once delivery guarantees and retries due to transport layer failures)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaConfigurationExtensions.EnableIdempotentSagas(Rebus.Config.OptionsConfigurer)">
            <summary>
            Enables idempotent sagas. When enabled, sagas derived from <see cref="T:Rebus.Sagas.Idempotent.IdempotentSaga`1"/> can be truly idempotent.
            This means that the saga instance stores the IDs of all handled messages, including all outgoing messages send when handling
            each incoming message - this way, the saga instance can guard itself against handling the same message twice, while still
            preserving externally visible behavior even when a message gets handled more than once.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaData">
            <summary>
            Convenient standard implementation of <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IdempotentSagaData.IdempotencyData">
            <summary>
            The idempotency data stores the side-effects
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep">
            <summary>
            Incoming pipeline step that checks the loaded saga data to see if the message currently being handled is a dupe.
            If it is, message dispatch is skipped, but any messages stored as outgoing messages from previously handling the incoming message
            will be sent 
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Checks the loaded saga data to see if the message currently being handled is a duplicate of a message that has previously been handled. 
            If that is the case, message dispatch is skipped, but any messages stored as outgoing messages from previously handling the incoming message will be sent.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IdempotentSagaOutgoingStep">
            <summary>
            Outgoing pipeline step that stores the sent message in the current saga data (if it is an <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.IdempotentSagaOutgoingStep.Process(Rebus.Pipeline.OutgoingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Carries out whichever logic it takes to do something good for the outgoing message :)
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.IIdempotentSagaData">
            <summary>
            Derivation of <see cref="T:Rebus.Sagas.ISagaData"/> that is capable of storing externally visible side-effects (i.e. outgoing messages)
            that were caused by handling specific incoming messages
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.IIdempotentSagaData.IdempotencyData">
            <summary>
            The idempotency data stores the side-effects
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.OutgoingMessage">
            <summary>
            An outgoing message is a <see cref="T:Rebus.Messages.TransportMessage"/> destined for one or more destinations. It is meant to be stored
            in an <see cref="T:Rebus.Sagas.Idempotent.IdempotencyData"/> instance inside an instance of <see cref="T:Rebus.Sagas.Idempotent.IIdempotentSagaData"/>.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessage.#ctor(System.Collections.Generic.IEnumerable{System.String},Rebus.Messages.TransportMessage)">
            <summary>
            Constructs the outgoing message destined for the given addresses
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessage.DestinationAddresses">
            <summary>
            Gets the addresses for which this <see cref="T:Rebus.Messages.TransportMessage"/> is supposed to be sent
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessage.TransportMessage">
            <summary>
            Gets the transport message
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Idempotent.OutgoingMessages">
            <summary>
            Contains all the <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> instances for a given incoming message
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessages.#ctor(System.String,System.Collections.Generic.IEnumerable{Rebus.Sagas.Idempotent.OutgoingMessage})">
            <summary>
            Constructs the instance for the given message ID, containing the given <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> instances
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId">
            <summary>
            Gets the ID of the incoming message
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessagesToSend">
            <summary>
            Gets all the outgoing messages to be sent as a consequence of handling the message with the ID <see cref="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId"/>
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Idempotent.OutgoingMessages.Add(Rebus.Sagas.Idempotent.OutgoingMessage)">
            <summary>
            Adds another <see cref="T:Rebus.Sagas.Idempotent.OutgoingMessage"/> as a side-effect of handling the message with the ID <see cref="P:Rebus.Sagas.Idempotent.OutgoingMessages.MessageId"/>
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaCorrelationProperty">
            <summary>
            Represents a path to a correlation property on a saga of a specific type
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaCorrelationProperty.PropertyName">
            <summary>
            Gets the name of the property
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaCorrelationProperty.SagaDataType">
            <summary>
            Gets the type of the saga data
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ISagaData">
            <summary>
            Interface of a saga data instance. The saga data represents the state of the state machine instance of the process manager,
            that the saga essentially implements.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaData.Id">
            <summary>
            Saga ID used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting the saga data.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.ISagaData.Revision">
            <summary>
            Saga instance revision used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting/updating the saga data.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaData">
            <summary>
            Convenient implementation of <see cref="T:Rebus.Sagas.ISagaData"/>
            </summary>
        </member>
        <member name="P:Rebus.Sagas.SagaData.Id">
            <summary>
            Saga ID used by Rebus. Do not mess with this one - - it will automatically be set by Rebus when inserting the saga data.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.SagaData.Revision">
            <summary>
            Saga instance revision used by Rebus. Do not mess with this one - it will automatically be set by Rebus when inserting/updating the saga data.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaDataCorrelationProperties">
            <summary>
            Contains a set of correlation properties relevant for one particular saga data
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.#ctor(System.Collections.Generic.Dictionary{System.Type,Rebus.Sagas.CorrelationProperty[]},System.Type)">
            <summary>
            Constructs the set
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.ForMessage(System.Object)">
            <summary>
            Looks up correlation properties relevant for the specified message type
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaDataCorrelationProperties.GetEnumerator">
            <summary>
            Gets the correlation properties contained in this collection
            </summary>
        </member>
        <member name="T:Rebus.Sagas.LoadSagaDataStep">
            <summary>
            Incoming step that loads and saves relevant saga data.
            </summary>
        </member>
        <member name="F:Rebus.Sagas.LoadSagaDataStep.IgnoredProperties">
            <summary>
            properties ignored by auto-setter (the one that automatically sets the correlation ID on a new saga data instance)
            </summary>
        </member>
        <member name="M:Rebus.Sagas.LoadSagaDataStep.#ctor(Rebus.Sagas.ISagaStorage,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the step with the given saga storage
            </summary>
        </member>
        <member name="M:Rebus.Sagas.LoadSagaDataStep.Process(Rebus.Pipeline.IncomingStepContext,System.Func{System.Threading.Tasks.Task})">
            <summary>
            For each <see cref="T:Rebus.Pipeline.Receive.HandlerInvoker"/> found in the current <see cref="T:Rebus.Pipeline.IncomingStepContext"/>'s <see cref="T:Rebus.Pipeline.Receive.HandlerInvokers"/>,
            this step will see if the invoker's handler is actually a <see cref="T:Rebus.Sagas.Saga"/>. If that is the case, the saga's correlation properties
            are used to see if a piece of existing saga data can be retrieved and mounted on the <see cref="P:Rebus.Sagas.Saga`1.Data"/> property.
            If no existing instance was found, but the saga implements <see cref="T:Rebus.Sagas.IAmInitiatedBy`1"/> for the current message,
            a new saga data instance will be created (and mounted). Otherwise, the message is ignored.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.CorrelationProperty">
            <summary>
            Represents a mapping from a field of an incoming message of a specific type to a specific property on a specific type of saga data
            </summary>
        </member>
        <member name="F:Rebus.Sagas.CorrelationProperty.AllowedCorrelationPropertyTypes">
            <summary>
            Defines the types that are allowed to use with saga data properties that are intended for correlation
            </summary>
        </member>
        <member name="M:Rebus.Sagas.CorrelationProperty.#ctor(System.Type,System.Func{System.Object,System.Object},System.Type,System.String,System.Type)">
            <summary>
            Constructs the correlation property
            </summary>
            <param name="messageType">Specifies the message type that this property can correlate</param>
            <param name="valueFromMessage">Specifies the function that will be called with the message instance in order to extract a value that should be used for correlation</param>
            <param name="sagaDataType">Specifies the type of saga data that this property can correlate to</param>
            <param name="propertyName">Specifies that property name on the saga data that this correlation addresses</param>
            <param name="sagaType">Specifies the saga type (i.e. the handler type) that contains the logic of the saga</param>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.MessageType">
            <summary>
            The message type that this property can correlate
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.ValueFromMessage">
            <summary>
            The function that will be called with the message instance in order to extract a value that should be used for correlation
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.SagaDataType">
            <summary>
            Gets the type of the saga's saga data
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.PropertyName">
            <summary>
            Gets the name of the correlation property
            </summary>
        </member>
        <member name="P:Rebus.Sagas.CorrelationProperty.SagaType">
            <summary>
            The saga type (i.e. the handler type) that contains the logic of the saga
            </summary>
        </member>
        <member name="T:Rebus.Sagas.ICorrelationConfig`1">
            <summary>
            Sets up the saga instance correlation configuration, i.e. it configures how the following question should be answered:
            "given this incoming message, how should Rebus figure out which saga instance should be loaded to handle it?"
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ICorrelationConfig`1.Correlate``1(System.Func{``0,System.Object},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Correlates an incoming message of type <typeparamref name="TMessage"/>, using the specified <paramref name="messageValueExtractorFunction"/> to
            extract a value from the message. The value will be used when looking up a saga data instance using the specified <paramref name="sagaDataValueExpression"/>.
            You could for example do something like this:
            <code>
            config.Correlate&lt;TradeApproved&gt;(t => t.Id, d => d.TradeId);
            </code>
            to look up a saga instance by the "TradeId" field, querying by the value of the "Id" property of the incoming "TradeApproved" message.
            </summary>
            <typeparam name="TMessage">Specifies the message type to configure a correlation for</typeparam>
            <param name="messageValueExtractorFunction">Configures a function to extract a value from the message. Since this is just a function, it may contain logic that e.g. concatenates fields, calls other functions, etc.</param>
            <param name="sagaDataValueExpression">Configures an expression, which will be used when querying the chosen <see cref="T:Rebus.Sagas.ISagaStorage"/> - since this is an expression, it must point to a simple property of the relevant <typeparamref name="TSagaData"/>.</param>
        </member>
        <member name="T:Rebus.Sagas.ISagaStorage">
            <summary>
            Abstraction for a mechanism that is capable of storing saga state, retrieving it again by querying for value on the state
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Find(System.Type,System.String,System.Object)">
            <summary>
            Finds an already-existing instance of the given saga data type that has a property with the given <paramref name="propertyName"/>
            whose value matches <paramref name="propertyValue"/>. Returns null if no such instance could be found
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Insert(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Inserts the given saga data as a new instance. Throws a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if another saga data instance
            already exists with a correlation property that shares a value with this saga data.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Update(Rebus.Sagas.ISagaData,System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaCorrelationProperty})">
            <summary>
            Updates the already-existing instance of the given saga data, throwing a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if another
            saga data instance exists with a correlation property that shares a value with this saga data, or if the saga data
            instance no longer exists.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.ISagaStorage.Delete(Rebus.Sagas.ISagaData)">
            <summary>
            Deletes the saga data instance, throwing a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> if the instance no longer exists
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Saga">
            <summary>
            Saga base class that allows for passing around saga instances without being bothered by the type of saga data they're handling. You should
            probably not inherit from this one, inherit your saga from <see cref="T:Rebus.Sagas.Saga`1"/> instead.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.UserHasOverriddenConflictResolutionMethod">
            <summary>
            Checks whether the <see cref="M:Rebus.Sagas.Saga`1.ResolveConflict(`0)"/> method is defined in <see cref="T:Rebus.Sagas.Saga`1"/>, returning
            true if it is NOT - because that means that the user has overridden the method and in this particular saga type can resolve conflicts. 
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.MarkAsComplete">
            <summary>
            Marks the current saga instance as completed, which means that it is either a) deleted from persistent storage in case
            it has been made persistent, or b) thrown out the window if it was never persisted in the first place.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga.MarkAsUnchanged">
            <summary>
            Marks the current saga instance as unchanged, causing any changes made to it to be ignored. Its revision will NOT be
            incremented
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Saga.IsNew">
            <summary>
            Gets whether the saga data instance is new
            </summary>
        </member>
        <member name="T:Rebus.Sagas.Saga`1">
            <summary>
            Generic saga base class that must be made concrete by supplying the <typeparamref name="TSagaData"/> type parameter.
            </summary>
        </member>
        <member name="P:Rebus.Sagas.Saga`1.Data">
            <summary>
            Gets or sets the relevant saga data instance for this saga handler
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga`1.CorrelateMessages(Rebus.Sagas.ICorrelationConfig{`0})">
            <summary>
            This method must be implemented in order to configure correlation of incoming messages with existing saga data instances.
            Use the injected <see cref="T:Rebus.Sagas.ICorrelationConfig`1"/> to set up the correlations, e.g. like so:
            <code>
            config.Correlate&lt;InitiatingMessage&gt;(m => m.OrderId, d => d.CorrelationId);
            config.Correlate&lt;CorrelatedMessage&gt;(m => m.CorrelationId, d => d.CorrelationId);
            </code>
            </summary>
        </member>
        <member name="M:Rebus.Sagas.Saga`1.ResolveConflict(`0)">
            <summary>
            Override this to be given an opportunity to resolve the conflict when a <see cref="T:Rebus.Exceptions.ConcurrencyException"/> occurs on an update.
            If a conflict cannot be resolved, feel free to bail out by throwing an exception.
            </summary>
        </member>
        <member name="T:Rebus.Sagas.SagaHelper">
            <summary>
            Helper class that can cache configured sets of correlation properties for various saga types
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaHelper.GetCorrelationProperties(System.Object,Rebus.Sagas.Saga)">
            <summary>
            Gets (most likely from a cache) the set of correlation properties relevant for the given saga handler.
            </summary>
        </member>
        <member name="M:Rebus.Sagas.SagaHelper.CreateNewSagaData(Rebus.Sagas.Saga)">
            <summary>
            Creates a new instance of the saga's saga data
            </summary>
        </member>
        <member name="T:Rebus.Serialization.DictionarySerializer">
            <summary>
            Generic serializer that serializes <see cref="T:System.Collections.Generic.Dictionary`2"/> of <see cref="T:System.String"/> keys and <see cref="T:System.String"/> values
            into JSON and back
            </summary>
        </member>
        <member name="M:Rebus.Serialization.DictionarySerializer.SerializeToString(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Serializes the given dictionary into a JSON string
            </summary>
        </member>
        <member name="M:Rebus.Serialization.DictionarySerializer.DeserializeFromString(System.String)">
            <summary>
            Deserializes the given JSON string into a dictionary
            </summary>
        </member>
        <member name="T:Rebus.Serialization.ObjectSerializer">
            <summary>
            Generic serializer that happily serializes rich objects. Uses JSON.NET internally with full type information.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.Serialize(System.Object)">
            <summary>
            Serializes the given object into a byte[]
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ObjectSerializer.Deserialize(System.Byte[])">
            <summary>
            Deserializes the given byte[] into an object
            </summary>
        </member>
        <member name="T:Rebus.Serialization.GenericJsonSerializer">
            <summary>
            Generic serializer that serializes an object into a string and vice versa. Uses a normal, compact JSON format,
            requiring the serialized type to be known at deserialization time
            </summary>
        </member>
        <member name="M:Rebus.Serialization.GenericJsonSerializer.Serialize``1(``0)">
            <summary>
            Serializes the given object to a string. No type information is included - therefore, abstract members etc.
            cannot be reproduced when deserializing
            </summary>
        </member>
        <member name="M:Rebus.Serialization.GenericJsonSerializer.Deserialize``1(System.String)">
            <summary>
            Deserializes the given JSON string to the type specified
            </summary>
        </member>
        <member name="T:Rebus.Serialization.ISerializer">
            <summary>
            Message serializer that should capable of safely roundtripping .NET message body objects to some serialized form and back
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ISerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the given <see cref="T:Rebus.Messages.Message"/> into a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.ISerializer.Deserialize(Rebus.Messages.TransportMessage)">
            <summary>
            Deserializes the given <see cref="T:Rebus.Messages.TransportMessage"/> back into a <see cref="T:Rebus.Messages.Message"/>
            </summary>
        </member>
        <member name="T:Rebus.Serialization.JsonSerializer">
            <summary>
            Implementation of <see cref="T:Rebus.Serialization.ISerializer"/> that uses Newtonsoft JSON.NET internally, with some pretty robust settings
            (i.e. full type info is included in the serialized format in order to support deserializing "unknown" types like
            implementations of interfaces, etc)
            </summary>
        </member>
        <member name="F:Rebus.Serialization.JsonSerializer.JsonUtf8ContentType">
            <summary>
            Proper content type when a message has been serialized with this serializer (or another compatible JSON serializer) and it uses the standard UTF8 encoding
            </summary>
        </member>
        <member name="F:Rebus.Serialization.JsonSerializer.JsonContentType">
            <summary>
            Contents type when the content is JSON
            </summary>
        </member>
        <member name="M:Rebus.Serialization.JsonSerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the given <see cref="T:Rebus.Messages.Message"/> into a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.JsonSerializer.Deserialize(Rebus.Messages.TransportMessage)">
            <summary>
            Deserializes the given <see cref="T:Rebus.Messages.TransportMessage"/> back into a <see cref="T:Rebus.Messages.Message"/>
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.FakeBusDisposed">
            <summary>
            Indicates that the bus was disposed
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.FakeBusEvent">
            <summary>
            Base type of all events that a <see cref="T:Rebus.Testing.FakeBus"/> can record.
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.FakeBusEvent.Time">
            <summary>
            Gets the time of when the event was recorded
            </summary>
        </member>
        <member name="M:Rebus.Testing.Events.FakeBusEvent.ToString">
            <summary>
            Gets a nice string representation of this particular fake bus event
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageDeferred">
            <summary>
            Recorded when a message was deferred
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferred.Delay">
            <summary>
            Gets the time span with which this message was delayed
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferred.CommandMessage">
            <summary>
            Gets the message that was deferred
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferred.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageDeferred`1">
            <summary>
            Recorded when a message was deferred
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageDeferred`1.CommandMessage">
            <summary>
            Gets the message that was deferred
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessagePublished">
            <summary>
            Recorded when an event was published
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessagePublished.EventMessage">
            <summary>
            Gets the event message that was published
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessagePublished.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessagePublished`1">
            <summary>
            Recorded when an event was published
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessagePublished`1.EventMessage">
            <summary>
            Gets the event message that was published
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageSent">
            <summary>
            Base event recorded when a message was sent - actual event will be <see cref="T:Rebus.Testing.Events.MessageSent`1"/>
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSent.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSent.CommandMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageSent`1">
            <summary>
            Recorded when a message was sent
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSent`1.CommandMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageSentToSelf">
            <summary>
            Recorded when a message was sent to the bus' own input queue
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSentToSelf.CommandMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSentToSelf.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.MessageSentToSelf`1">
            <summary>
            Recorded when a message was sent to the bus' own input queue
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.MessageSentToSelf`1.CommandMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.ReplyMessageSent">
            <summary>
            Recorded when a reply message was sent
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.ReplyMessageSent.ReplyMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.ReplyMessageSent.OptionalHeaders">
            <summary>
            Gets the optional headers if they were supplied, or null if they weren't
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.ReplyMessageSent`1">
            <summary>
            Recorded when a reply message was sent
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.ReplyMessageSent`1.ReplyMessage">
            <summary>
            Gets the message that was sent
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.Subscribed">
            <summary>
            Recorded when a subscription was made
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.Subscribed.EventType">
            <summary>
            Gets the type of event that was subscribed to
            </summary>
        </member>
        <member name="T:Rebus.Testing.Events.Unsubscribed">
            <summary>
            Recorded when a subscription was revoked
            </summary>
        </member>
        <member name="P:Rebus.Testing.Events.Unsubscribed.EventType">
            <summary>
            Gets the type of event that was unsubscribed to
            </summary>
        </member>
        <member name="T:Rebus.Testing.FakeBus">
            <summary>
            The fake bus is an implementation of <see cref="T:Rebus.Bus.IBus"/> that can be used for testing. The fake bus
            just collects information about what has happened to it, allowing you to query that information after the
            fact by checking <see cref="P:Rebus.Testing.FakeBus.Events"/>
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.Events">
             <summary>
             Gets all events recorded at this point. Query this in order to check what happened to the fake bus while
             it participated in a test - e.g. like this:
             <code>
             await fakeBus.Send(new MyMessage("woohoo!"));
            
             var sentMessagesWithMyGreeting = fakeBus.Events
                 .OfType&lt;MessageSent&lt;MyMessage&gt;&gt;()
                 .Count(m => m.CommandMessage.Text == "woohoo!");
            
             Assert.That(sentMessagesWithMyGreeting, Is.EqualTo(1));
             </code>
             </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.On``1(System.Action{``0})">
            <summary>
            Adds a callback to be invoked when new events are recorded in the fake bus
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Clear">
            <summary>
            Clears all events recorded by the fake bus. Registered callbacks will NOT be cleared
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.SendLocal(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to our own input queue address
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Send(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified message to a destination that is determined by calling <see cref="M:Rebus.Routing.IRouter.GetDestinationAddress(Rebus.Messages.Message)"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Reply(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sends the specified reply message to a destination that is determined by looking up the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header of the message currently being handled.
            This method can only be called from within a message handler.
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Defer(System.TimeSpan,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Defers the delivery of the message by attaching a <see cref="F:Rebus.Messages.Headers.DeferredUntil"/> header to it and delivering it to the configured timeout manager endpoint
            (defaults to be ourselves). When the time is right, the deferred message is returned to the address indicated by the <see cref="F:Rebus.Messages.Headers.ReturnAddress"/> header.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.Advanced">
            <summary>
            Gets the advanced API (which is not currently supported for the fake bus - throws an <see cref="T:System.InvalidOperationException"/> at the moment)
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Subscribe``1">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Subscribe(System.Type)">
            <summary>
            Subscribes to the topic defined by the assembly-qualified name of <paramref name="eventType"/>. 
            While this kind of subscription can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Unsubscribe``1">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <typeparamref name="TEvent"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Unsubscribe(System.Type)">
            <summary>
            Unsubscribes from the topic defined by the assembly-qualified name of <paramref name="eventType"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Publish(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Publishes the event message on the topic defined by the assembly-qualified name of the type of the message.
            While this kind of pub/sub can work universally with the general topic-based routing, it works especially well with type-based routing,
            which can be enabled by going 
            <code>
            Configure.With(...)
                .(...)
                .Routing(r => r.TypeBased()
                        .Map&lt;SomeMessage&gt;("someEndpoint")
                        .(...))
            </code>
            in the configuration
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Rebus.Testing.Internals.LockStepper">
            <summary>
            Pipeline step that makes it easy to block message processing until some particular point in time.
            This is done by adding a <see cref="T:System.Threading.ManualResetEvent"/> to it, which will be set the next time
            a message has been processed
            </summary>
        </member>
        <member name="T:Rebus.Testing.LogEvent">
            <summary>
            Represents a log event emitted from Rebus' internals during saga testing with <see cref="T:Rebus.Testing.SagaFixture`1"/>
            </summary>
        </member>
        <member name="P:Rebus.Testing.LogEvent.Time">
            <summary>
            Gets the (Rebus) time of when the event was emitted
            </summary>
        </member>
        <member name="P:Rebus.Testing.LogEvent.Level">
            <summary>
            Gets the associated log level
            </summary>
        </member>
        <member name="P:Rebus.Testing.LogEvent.Text">
            <summary>
            Gets a string representation of the log event
            </summary>
        </member>
        <member name="P:Rebus.Testing.LogEvent.ExceptionOrNull">
            <summary>
            Gets the associated exception (or null if none was included)
            </summary>
        </member>
        <member name="P:Rebus.Testing.LogEvent.SourceType">
            <summary>
            Gets the type that the logger was associated with
            </summary>
        </member>
        <member name="M:Rebus.Testing.LogEvent.ToString">
            <summary>
            Gets a string-formatted version of the log event
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture">
            <summary>
            Saga fixture factory class - can be used to create an appropriate <see cref="T:Rebus.Testing.SagaFixture`1"/> for a saga
            handler to participate in white-box testing scenarios
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture.For``1">
            <summary>
            Creates a saga fixture for the specified saga handler, which must have a default constructor. If the saga handler
            requires any parameters to be created, use the <see cref="M:Rebus.Testing.SagaFixture.For``1(System.Func{``0})"/> overload that
            accepts a factory function as a saga handler instance creator
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture.For``1(System.Func{``0})">
            <summary>
            Creates a saga fixture for the specified saga handler, which will be instantiated by the given factory method
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture`1">
            <summary>
            Saga fixture that wraps an in-mem Rebus that 
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.Correlated">
            <summary>
            Event that is raised whenever a message could be successfully correlated with a saga data instance. The instance
            is passed to the event handler
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.CouldNotCorrelate">
            <summary>
            Event that is raised whenever a message could NOT be successfully correlated with a saga data instance. The event is
            raised regardless of whether the incoming message is allowed to initiate a new saga or not.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.Created">
            <summary>
            Event that is raised when the incoming message resulted in creating a new saga data instance. The created instance
            is passed to the event handler.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.Updated">
            <summary>
            Event that is raised when the incoming message resulted in updating an existing saga data instance. The updated instance
            is passed to the event handler.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.Deleted">
            <summary>
            Event that is raised when the incoming message resulted in deleting an existing saga data instance. The deleted instance
            is passed to the event handler.
            </summary>
        </member>
        <member name="P:Rebus.Testing.SagaFixture`1.Data">
            <summary>
            Gets all of the currently existing saga data instances
            </summary>
        </member>
        <member name="P:Rebus.Testing.SagaFixture`1.LogEvents">
            <summary>
            Gets all log events emitted by the internal Rebus instance
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.Deliver(System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Delivers the given message to the saga handler
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.Add(Rebus.Sagas.ISagaData)">
            <summary>
            Adds the given saga data to the available saga data in the saga fixture. If the saga data is not provided
            with an ID, a new guid will automatically be assigned internally.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.AddRange(System.Collections.Generic.IEnumerable{Rebus.Sagas.ISagaData})">
            <summary>
            Adds the given saga data instances to the available saga data in the fixture. If the saga data instances have not been provided
            with an ID, a new guid will automatically be assigned internally.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.Dispose">
            <summary>
            Shuts down the in-mem bus that holds the saga handler
            </summary>
        </member>
        <member name="T:Rebus.Threading.AsyncBottleneck">
            <summary>
            The "bottleneck" is a wrapper around <see cref="T:System.Threading.SemaphoreSlim"/> that makes it easy to decrese the count of a semaphore,
            increasing it again after having used it.
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncBottleneck.#ctor(System.Int32)">
            <summary>
            Constructs the bottleneck, allowing for <paramref name="maxParallelOperationsToAllow"/> parallel operations
            to be performed
            </summary>
        </member>
        <member name="M:Rebus.Threading.AsyncBottleneck.Enter(System.Threading.CancellationToken)">
            <summary>
            Grabs the semaphore and releases an <see cref="T:System.IDisposable"/> that will release it again when disposed
            </summary>
        </member>
        <member name="T:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTask"/> that uses a <see cref="T:System.Threading.Timer"/> to schedule callbacks
            </summary>
        </member>
        <member name="F:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.DefaultInterval">
            <summary>
            This is the default interval between invocations if the periodic action, unless the <see cref="P:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Interval"/> property is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.#ctor(System.String,System.Func{System.Threading.Tasks.Task},Rebus.Logging.IRebusLoggerFactory,System.Boolean)">
            <summary>
            Constructs the periodic background task with the given <paramref name="description"/>, periodically executing the given <paramref name="action"/>,
            waiting <see cref="P:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Interval"/> between invocations.
            </summary>
        </member>
        <member name="P:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Interval">
            <summary>
            Configures the interval between invocations. The default value is <see cref="F:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.DefaultInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask.Dispose">
            <summary>
            Stops the background task
            </summary>
        </member>
        <member name="T:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTaskFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTaskFactory"/> that uses a <see cref="T:System.Timers.Timer"/> to schedule callbacks
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTaskFactory.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the async task factory
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTaskFactory.Create(System.String,System.Func{System.Threading.Tasks.Task},System.Boolean,System.Int32)">
            <summary>
            Creates a new async task
            </summary>
        </member>
        <member name="T:Rebus.Threading.TaskParallelLibrary.TplAsyncTask">
            <summary>
            <see cref="T:System.Threading.Tasks.Task"/>-based background timer thingie, that will periodically call an async <see cref="T:System.Func`1"/>
             </summary>
        </member>
        <member name="F:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.DefaultInterval">
            <summary>
            This is the default interval between invocations if the periodic action, unless the <see cref="P:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Interval"/> property is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.#ctor(System.String,System.Func{System.Threading.Tasks.Task},Rebus.Logging.IRebusLoggerFactory,System.Boolean)">
            <summary>
            Constructs the periodic background task with the given <paramref name="description"/>, periodically executing the given <paramref name="action"/>,
            waiting <see cref="P:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Interval"/> between invocations.
            </summary>
        </member>
        <member name="P:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Interval">
            <summary>
            Configures the interval between invocations. The default value is <see cref="F:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.DefaultInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTask.Dispose">
            <summary>
            Stops the background task
            </summary>
        </member>
        <member name="T:Rebus.Threading.TaskParallelLibrary.TplAsyncTaskFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTaskFactory"/> that uses TPL to execute the background task
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTaskFactory.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Creates a new TPL-based async task factory
            </summary>
        </member>
        <member name="M:Rebus.Threading.TaskParallelLibrary.TplAsyncTaskFactory.Create(System.String,System.Func{System.Threading.Tasks.Task},System.Boolean,System.Int32)">
            <summary>
            Creates a new async task
            </summary>
        </member>
        <member name="T:Rebus.Threading.IAsyncTask">
            <summary>
            A task that will be executed periodically. Starts executing as soon as <see cref="M:Rebus.Threading.IAsyncTask.Start"/>
            is called, beginning with waiting the full interval before the first execution. Stops running when it is disposed.
            </summary>
        </member>
        <member name="M:Rebus.Threading.IAsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="T:Rebus.Threading.IAsyncTaskFactory">
            <summary>
            Factory that is capable of creating lightweight async tasks for doing background work
            </summary>
        </member>
        <member name="M:Rebus.Threading.IAsyncTaskFactory.Create(System.String,System.Func{System.Threading.Tasks.Task},System.Boolean,System.Int32)">
            <summary>
            Creates a new async task
            </summary>
        </member>
        <member name="T:Rebus.Threading.ParallelOperationsManager">
            <summary>
            Helper that counts the number of parallel operations. Not reentrant, this bad boy is meant to be used from a single worker thread
            that may use it to count the number of async parallel operations waiting to be completed
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.#ctor(System.Int32)">
            <summary>
            Constructs the container with the given max number of parallel async operations to allow
            </summary>
        </member>
        <member name="P:Rebus.Threading.ParallelOperationsManager.HasPendingTasks">
            <summary>
            Gets whether any async tasks are currently waiting to be completed
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.TryBegin">
            <summary>
            Begins another async operation and returns an <see cref="T:System.IDisposable"/> that must be disposed in order to mark the end of the async operation
            </summary>
        </member>
        <member name="T:Rebus.Threading.ParallelOperationsManager.ParallelOperation">
            <summary>
            Gets a disposable token for the parallel operation - the token indicates whether it's ok to continue
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.ParallelOperation.Dispose">
            <summary>
            Ends this parallel operation
            </summary>
        </member>
        <member name="M:Rebus.Threading.ParallelOperationsManager.ParallelOperation.CanContinue">
            <summary>
            Gets whether the token was successfully acquired
            </summary>
        </member>
        <member name="T:Rebus.Threading.SystemTimersTimer.TimerAsyncTask">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTask"/> that uses a <see cref="T:System.Timers.Timer"/> to schedule callbacks
            </summary>
        </member>
        <member name="F:Rebus.Threading.SystemTimersTimer.TimerAsyncTask.DefaultInterval">
            <summary>
            This is the default interval between invocations if the periodic action, unless the <see cref="P:Rebus.Threading.SystemTimersTimer.TimerAsyncTask.Interval"/> property is set to something else
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemTimersTimer.TimerAsyncTask.#ctor(System.String,System.Func{System.Threading.Tasks.Task},Rebus.Logging.IRebusLoggerFactory,System.Boolean)">
            <summary>
            Constructs the periodic background task with the given <paramref name="description"/>, periodically executing the given <paramref name="action"/>,
            waiting <see cref="P:Rebus.Threading.SystemTimersTimer.TimerAsyncTask.Interval"/> between invocations.
            </summary>
        </member>
        <member name="P:Rebus.Threading.SystemTimersTimer.TimerAsyncTask.Interval">
            <summary>
            Configures the interval between invocations. The default value is <see cref="F:Rebus.Threading.SystemTimersTimer.TimerAsyncTask.DefaultInterval"/>
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemTimersTimer.TimerAsyncTask.Start">
            <summary>
            Starts the task
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemTimersTimer.TimerAsyncTask.Dispose">
            <summary>
            Stops the background task
            </summary>
        </member>
        <member name="T:Rebus.Threading.SystemTimersTimer.TimerAsyncTaskFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Threading.IAsyncTaskFactory"/> that uses a <see cref="T:System.Timers.Timer"/> to schedule callbacks
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemTimersTimer.TimerAsyncTaskFactory.#ctor(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the async task factory
            </summary>
        </member>
        <member name="M:Rebus.Threading.SystemTimersTimer.TimerAsyncTaskFactory.Create(System.String,System.Func{System.Threading.Tasks.Task},System.Boolean,System.Int32)">
            <summary>
            Creates a new async task
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.DueMessage">
            <summary>
            Represents a message that was deferred and is now due. The message has some headers and a body and can be turned into
            a <see cref="T:Rebus.Messages.TransportMessage"/> by calling <see cref="M:Rebus.Timeouts.DueMessage.ToTransportMessage"/>. The due message can be constructed in a
            way that can perform an arbitrary action in order to mark the due message as successfully delivered.
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[],System.Func{System.Threading.Tasks.Task})">
            <summary>
            Constructs the due message with the given headers and body, storing the given <paramref name="completeAction"/> to be
            executed when the message's <see cref="M:Rebus.Timeouts.DueMessage.MarkAsCompleted"/> method is called.
            </summary>
        </member>
        <member name="P:Rebus.Timeouts.DueMessage.Headers">
            <summary>
            Gets the headers of this due message
            </summary>
        </member>
        <member name="P:Rebus.Timeouts.DueMessage.Body">
            <summary>
            Gets the body data of this due message
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.MarkAsCompleted">
            <summary>
            Marks the due message as successfully handled, which should probably be done when the message has been safely sent to the proper recipient
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessage.ToTransportMessage">
            <summary>
            Returns the headers and the body of this due message in a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.DueMessagesResult">
            <summary>
            Represents the result of calling <see cref="M:Rebus.Timeouts.ITimeoutManager.GetDueMessages"/> - contains zero or mode <see cref="T:Rebus.Timeouts.DueMessage"/> objects
            where each due message can be individually marked as successfully delivered 
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.#ctor(System.Collections.Generic.IEnumerable{Rebus.Timeouts.DueMessage},System.Func{System.Threading.Tasks.Task})">
            <summary>
            Constructs the result, wrapping the given list of due messages, performing the given action when the instance is disposed
            </summary>
        </member>
        <member name="F:Rebus.Timeouts.DueMessagesResult.Empty">
            <summary>
            Gets an empty due messages result
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.Complete">
            <summary>
            Completes the result by running the clean-up action
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.Dispose">
            <summary>
            Invokes the cleanup action
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.DueMessagesResult.GetEnumerator">
            <summary>
            Returns all due messages from this result
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.TimeoutsConfigurationExtensions">
            <summary>
            Configuration extensions for timeouts
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.TimeoutsConfigurationExtensions.UseExternalTimeoutManager(Rebus.Config.StandardConfigurer{Rebus.Timeouts.ITimeoutManager},System.String)">
            <summary>
            Configures Rebus to use another endpoint as the timeout manager
            </summary>
        </member>
        <member name="T:Rebus.Timeouts.ITimeoutManager">
            <summary>
            Abstraction for a mechanism that is capable of storing deferred messages until the time where it's appropriate for it to be delivered.
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.ITimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])">
            <summary>
            Stores the message with the given headers and body data, delaying it until the specified <paramref name="approximateDueTime"/>
            </summary>
        </member>
        <member name="M:Rebus.Timeouts.ITimeoutManager.GetDueMessages">
            <summary>
            Gets due messages as of now, given the approximate due time that they were stored with when <see cref="M:Rebus.Timeouts.ITimeoutManager.Defer(System.DateTimeOffset,System.Collections.Generic.Dictionary{System.String,System.String},System.Byte[])"/> was called
            </summary>
        </member>
        <member name="T:Rebus.Time.RebusTimeMachine">
            <summary>
            Test utility that makes it easy to fake the time returned by <see cref="T:Rebus.Time.RebusTime"/>
            </summary>
        </member>
        <member name="M:Rebus.Time.RebusTimeMachine.FakeIt(System.DateTimeOffset,System.Boolean)">
            <summary>
            Fakes the current time to the time specified, making slight increments in time for each invocation
            (the slight increments can be turned off by setting <paramref name="incrementSlightlyOnEachInvocation"/> to false)
            </summary>
        </member>
        <member name="M:Rebus.Time.RebusTimeMachine.Reset">
            <summary>
            Resets the time factory back to returning the real time
            </summary>
        </member>
        <member name="T:Rebus.Time.RebusTime">
            <summary>
            Global clock that Rebus services should use if they need to look up the current time
            </summary>
        </member>
        <member name="P:Rebus.Time.RebusTime.Now">
            <summary>
            Gets the current time
            </summary>
        </member>
        <member name="T:Rebus.Transport.AmbientTransactionContext">
            <summary>
            Provides an "ambient" context for stashing away an instance that implements the current <see cref="T:Rebus.Transport.ITransactionContext"/>. The
            ambient transaction context is automatically preserved even though threads are changed etc.
            </summary>
        </member>
        <member name="P:Rebus.Transport.AmbientTransactionContext.Current">
            <summary>
            Gets/sets the current transaction context from the call context's logical data slot (which is automatically transferred to continuations when resuming
            awaited calls)
            </summary>
        </member>
        <member name="T:Rebus.Transport.FileSystem.FileSystemTransport">
            <summary>
            Transport implementation that uses the file system to send/receive messages.
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.#ctor(System.String,System.String)">
            <summary>
            Constructs the file system transport to create "queues" as subdirectories of the specified base directory.
            While it is apparent that <seealso cref="F:Rebus.Transport.FileSystem.FileSystemTransport._baseDirectory"/> must be a valid directory name, please note that 
            <seealso cref="F:Rebus.Transport.FileSystem.FileSystemTransport._inputQueue"/> must not contain any invalid path either.
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.CreateQueue(System.String)">
            <summary>
            Creates a "queue" (i.e. a directory) with the given name
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the specified message to the logical queue specified by <paramref name="destinationQueueName"/> by writing
            a JSON serialied text to a file in the corresponding directory. The actual write operation is delayed until
            the commit phase of the queue transaction unless we're non-transactional, in which case it is written immediately.
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Receives the next message from the logical input queue by loading the next file from the corresponding directory,
            deserializing it, deleting it when the transaction is committed.
            </summary>
        </member>
        <member name="P:Rebus.Transport.FileSystem.FileSystemTransport.Address">
            <summary>
            Gets the logical input queue name which for this transport correponds to a subdirectory of the specified base directory.
            For other transports, this is a global "address", but for this transport the address space is confined to the base directory.
            Therefore, the global address is the same as the input queue name.
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransport.Initialize">
            <summary>
            Ensures that the "queue" is initialized (i.e. that the corresponding subdirectory exists).
            </summary>
        </member>
        <member name="T:Rebus.Transport.FileSystem.FileSystemTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the file system transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransportConfigurationExtensions.UseFileSystem(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String)">
            <summary>
            Configures Rebus to use the file system to transport messages. The specified <paramref name="baseDirectory"/> will be used as the base directory
            within which subdirectories will be created for each logical queue.
            </summary>
        </member>
        <member name="M:Rebus.Transport.FileSystem.FileSystemTransportConfigurationExtensions.UseFileSystemAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String)">
            <summary>
            Configures Rebus to use the file system to transport messages, as a one-way client. The specified <paramref name="baseDirectory"/> will be used as the base directory
            within which subdirectories will be created for each logical queue.
            </summary>
        </member>
        <member name="T:Rebus.Transport.Msmq.MsmqTransportConfigurationBuilder">
            <summary>
            MSMQ configuration builder that can be used to customize how certain MSMQ operations are performed
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransportConfigurationBuilder.OnCreated(System.Action{System.Messaging.MessageQueue})">
            <summary>
            Adds a callback to be invoked when a new queue is created. Callbacks will be called AFTER the default permissions
            have been applied, which means that it is possible to e.g. remove the Administrators group's <see cref="F:System.Messaging.MessageQueueAccessRights.FullControl"/> 
            permission again in order to avoid this particular default
            </summary>
        </member>
        <member name="T:Rebus.Transport.Msmq.MsmqTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the MSMQ transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransportConfigurationExtensions.UseMsmq(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String)">
            <summary>
            Configures Rebus to use MSMQ to transport messages, receiving messages from the specified <paramref name="inputQueueName"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransportConfigurationExtensions.UseMsmqAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport})">
            <summary>
            Configures Rebus to use MSMQ to transport messages as a one-way client (i.e. will not be able to receive any messages)
            </summary>
        </member>
        <member name="T:Rebus.Transport.Msmq.MsmqTransport">
            <summary>
            Implementation of <see cref="T:Rebus.Transport.ITransport"/> that uses MSMQ to do its thing
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.#ctor(System.String,Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Constructs the transport with the specified input queue address
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.AddQueueCallback(System.Action{System.Messaging.MessageQueue})">
            <summary>
            Adds a callback to be invoked when a new queue is created. Can be used e.g. to customize permissions
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.Initialize">
            <summary>
            Initializes the transport by creating the input queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.CreateQueue(System.String)">
            <summary>
            Creates a queue with the given address, unless the address is of a remote queue - in that case,
            this call is ignored
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.PurgeInputQueue">
            <summary>
            Deletes all messages in the input queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given transport message to the specified destination address using MSMQ. Will use the existing <see cref="T:System.Messaging.MessageQueueTransaction"/> stashed
            under the <see cref="F:Rebus.Transport.Msmq.MsmqTransport.CurrentTransactionKey"/> key in the given <paramref name="context"/>, or else it will create one and add it.
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Received the next available transport message from the input queue via MSMQ. Will create a new <see cref="T:System.Messaging.MessageQueueTransaction"/> and stash
            it under the <see cref="F:Rebus.Transport.Msmq.MsmqTransport.CurrentTransactionKey"/> key in the given <paramref name="context"/>. If one already exists, an exception will be thrown
            (because we should never have to receive multiple messages in the same transaction)
            </summary>
        </member>
        <member name="P:Rebus.Transport.Msmq.MsmqTransport.Address">
            <summary>
            Gets the input queue address of this MSMQ queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.Dispose">
            <summary>
            Disposes the input message queue object
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqTransport.UseLegacyHeaderSerialization">
            <summary>
            Configures the transport to serialize headers in "legacy mode", which means that they're UTF7-encoded and not UTF8
            </summary>
        </member>
        <member name="T:Rebus.Transport.Msmq.MsmqUtil">
            <summary>
            Utils class for various MSMQ operations
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.PurgeQueue(System.String)">
            <summary>
            Deletes all messages from the queue with the specified name
            </summary>
            <param name="queueName"></param>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.GetPath(System.String)">
            <summary>
            Gets the MSMQ style path for the queue with the given name
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.GetFullPath(System.String)">
            <summary>
            Gets the MSMQ style path for the queue with the given name, always machine-qualified, even when the queue is local
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.GenerateFullPath(System.String,System.String)">
            <summary>
            Generates from the given <paramref name="machineName"/> and <paramref name="queueName"/> the full, MSMQ style queue path.
            It goes something like this: <code>FormatName:DIRECT=OS:SOME_MACHINE\private$\SOME_QUEUE</code> when addressing
            by machine name, and like this <code>FormatName:DIRECT=TCP:10.10.1.1\private$\SOME_QUEUE</code> when addressing
            by IP address.
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.QueueExists(System.String)">
            <summary>
            Returns whether an MSMQ queue with the given name exists
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.Delete(System.String)">
            <summary>
            Deletes the MSMQ queue with the given name
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.EnsureQueueExists(System.String,Rebus.Logging.ILog,System.Action{System.Messaging.MessageQueue})">
            <summary>
            Creates the MSMQ queue with the specified path if it does not already exist. If it is created, the user account
            of the currently executing process will get <see cref="F:System.Messaging.MessageQueueAccessRights.GenericWrite"/> permissions to it,
            and the local administrators group will get <see cref="F:System.Messaging.MessageQueueAccessRights.FullControl"/>.
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.EnsureMessageQueueIsTransactional(System.String)">
            <summary>
            Verifies that the queue with the given <paramref name="path"/> is transaction. If that is not the case, a <see cref="T:Rebus.Exceptions.RebusApplicationException"/>
            is thrown with an explanation of the problem
            </summary>
        </member>
        <member name="M:Rebus.Transport.Msmq.MsmqUtil.IsLocal(System.String)">
            <summary>
            Returns whther the queue with the specified name is local
            </summary>
        </member>
        <member name="T:Rebus.Transport.SqlServer.SqlServerTransport">
            <summary>
            Implementation of <see cref="T:Rebus.Transport.ITransport"/> that uses SQL Server to do its thing
            </summary>
        </member>
        <member name="F:Rebus.Transport.SqlServer.SqlServerTransport.MessagePriorityHeaderKey">
            <summary>
            Special message priority header that can be used with the <see cref="T:Rebus.Transport.SqlServer.SqlServerTransport"/>. The value must be an <see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:Rebus.Transport.SqlServer.SqlServerTransport.DefaultExpiredMessagesCleanupInterval">
            <summary>
            Default interval that will be used for <see cref="P:Rebus.Transport.SqlServer.SqlServerTransport.ExpiredMessagesCleanupInterval"/> unless it is explicitly set to something else
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.#ctor(Rebus.Persistence.SqlServer.IDbConnectionProvider,System.String,System.String,Rebus.Logging.IRebusLoggerFactory,Rebus.Threading.IAsyncTaskFactory)">
            <summary>
            Constructs the transport with the given <see cref="T:Rebus.Persistence.SqlServer.IDbConnectionProvider"/>, using the specified <paramref name="tableName"/> to send/receive messages,
            querying for messages with recipient = <paramref name="inputQueueName"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.Initialize">
            <summary>
            Initializes the transport by starting a task that deletes expired messages from the SQL table
            </summary>
        </member>
        <member name="P:Rebus.Transport.SqlServer.SqlServerTransport.ExpiredMessagesCleanupInterval">
            <summary>
            Configures the interval between periodic deletion of expired messages. Defaults to <see cref="F:Rebus.Transport.SqlServer.SqlServerTransport.DefaultExpiredMessagesCleanupInterval"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.SqlServer.SqlServerTransport.Address">
            <summary>
            Gets the name that this SQL transport will use to query by when checking the messages table
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.CreateQueue(System.String)">
            <summary>
            The SQL transport doesn't really have queues, so this function does nothing
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.EnsureTableIsCreated">
            <summary>
            Checks if the table with the configured name exists - if not, it will be created
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given transport message to the specified logical destination address by adding it to the messages table.
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Receives the next message by querying the messages table for a message with a recipient matching this transport's <see cref="P:Rebus.Transport.SqlServer.SqlServerTransport.Address"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransport.Dispose">
            <summary>
            Shuts down the background timer
            </summary>
        </member>
        <member name="T:Rebus.Transport.SqlServer.SqlServerTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the SQL transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransportConfigurationExtensions.UseSqlServerAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{System.Threading.Tasks.Task{Rebus.Persistence.SqlServer.IDbConnection}},System.String)">
            <summary>
            Configures Rebus to use SQL Server to transport messages as a one-way client (i.e. will not be able to receive any messages).
            The table specified by <paramref name="tableName"/> will be used to store messages.
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransportConfigurationExtensions.UseSqlServerAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String)">
            <summary>
            Configures Rebus to use SQL Server to transport messages as a one-way client (i.e. will not be able to receive any messages).
            The table specified by <paramref name="tableName"/> will be used to store messages.
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransportConfigurationExtensions.UseSqlServer(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.Func{System.Threading.Tasks.Task{Rebus.Persistence.SqlServer.IDbConnection}},System.String,System.String)">
            <summary>
            Configures Rebus to use SQL Server as its transport. The table specified by <paramref name="tableName"/> will be used to
            store messages, and the "queue" specified by <paramref name="inputQueueName"/> will be used when querying for messages.
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="M:Rebus.Transport.SqlServer.SqlServerTransportConfigurationExtensions.UseSqlServer(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},System.String,System.String,System.String)">
            <summary>
            Configures Rebus to use SQL Server as its transport. The table specified by <paramref name="tableName"/> will be used to
            store messages, and the "queue" specified by <paramref name="inputQueueName"/> will be used when querying for messages.
            The message table will automatically be created if it does not exist.
            </summary>
        </member>
        <member name="T:Rebus.Transport.TransactionContextExtensions">
            <summary>
            Nifty extensions to the transaction context, mostly working on the <see cref="P:Rebus.Transport.ITransactionContext.Items"/> dictionary
            </summary>
        </member>
        <member name="M:Rebus.Transport.TransactionContextExtensions.GetOrNull``1(Rebus.Transport.ITransactionContext,System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, returning null if the key does not exist.
            If the key exists, but the object could not be cast to the given type, a nice exception is throws
            </summary>
        </member>
        <member name="M:Rebus.Transport.TransactionContextExtensions.GetOrThrow``1(Rebus.Transport.ITransactionContext,System.String)">
            <summary>
            Gets the item with the given key and type from the dictionary of objects, throwing a nice exception if either the key
            does not exist, or the found value cannot be cast to the given type
            </summary>
        </member>
        <member name="M:Rebus.Transport.TransactionContextExtensions.GetOrAdd``1(Rebus.Transport.ITransactionContext,System.String,System.Func{``0})">
            <summary>
            Provides a shortcut to the transaction context's <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})"/>,
            only as a typed version that 
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemNetwork">
            <summary>
            Defines a network that the in-mem transport can work on, functioning as a namespace for the queue addresses
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.#ctor(System.Boolean)">
            <summary>
            Constructs the in-mem network, optionally (if <paramref name="outputEventsToConsole"/> is set to true) outputting information
            about what is happening inside it to <see cref="P:System.Console.Out"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.Reset">
            <summary>
            Resets the network (i.e. all queues and their messages are deleted)
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.Deliver(System.String,Rebus.Transport.InMem.InMemTransportMessage,System.Boolean)">
            <summary>
            Delivers the specified <see cref="T:Rebus.Transport.InMem.InMemTransportMessage"/> to the address specified by <paramref name="destinationAddress"/>.
            If <paramref name="alwaysQuiet"/> is set to true, no events will ever be printed to <see cref="P:System.Console.Out"/>
            (can be used by an in-mem transport to return a message to a queue, as if there was a queue transaction that was rolled back)
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.GetNextOrNull(System.String)">
            <summary>
            Gets the next message from the queue with the given <paramref name="inputQueueName"/>, returning null if no messages are available.
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.HasQueue(System.String)">
            <summary>
            Returns whether the network has a queue with the specified name
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemNetwork.CreateQueue(System.String)">
            <summary>
            Creates a queue on the network with the specified name
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransport">
            <summary>
            In-mem implementation of <see cref="T:Rebus.Transport.ITransport"/> that uses one particular <see cref="T:Rebus.Transport.InMem.InMemNetwork"/> to deliver messages. Can
            be used for in-process messaging and unit testing
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.#ctor(Rebus.Transport.InMem.InMemNetwork,System.String)">
            <summary>
            Creates the transport, using the specified <see cref="T:Rebus.Transport.InMem.InMemNetwork"/> to deliver/receive messages. This transport will have
            <paramref name="inputQueueAddress"/> as its input queue address, and thus will attempt to receive messages from the queue with that
            name out of the given <paramref name="network"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.CreateQueue(System.String)">
            <summary>
            Creates a queue with the given address
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Delivers the given message to the queue identitied by the given <paramref name="destinationAddress"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Receives the next message from the queue identified by the configured <see cref="P:Rebus.Transport.InMem.InMemTransport.Address"/>, returning null if none was available
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransport.Initialize">
            <summary>
            Initializes the transport by creating its own input queue
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransport.Address">
            <summary>
            Gets the input queue
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransportConfigurationExtensions">
            <summary>
            Configuration extensions for the in-mem transport
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportConfigurationExtensions.UseInMemoryTransport(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},Rebus.Transport.InMem.InMemNetwork,System.String)">
            <summary>
            Configures Rebus to use in-mem message queues, delivering/receiving from the specified <see cref="T:Rebus.Transport.InMem.InMemNetwork"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportConfigurationExtensions.UseInMemoryTransportAsOneWayClient(Rebus.Config.StandardConfigurer{Rebus.Transport.ITransport},Rebus.Transport.InMem.InMemNetwork)">
            <summary>
            Configures Rebus to use in-mem message queues, configuring this instance to be a one-way client
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransportMessage">
            <summary>
            Represents a transport message that was delivered to an in-mem message queue
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportMessage.#ctor(Rebus.Messages.TransportMessage)">
            <summary>
            Constructs the in-mem transport message from the given <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransportMessage.Age">
            <summary>
            Gets the age of this in-mem transport message
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransportMessage.Headers">
            <summary>
            Gets the headers of this in-mem transport message
            </summary>
        </member>
        <member name="P:Rebus.Transport.InMem.InMemTransportMessage.Body">
            <summary>
            Gets the body data of this in-mem transport message
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportMessage.ToTransportMessage">
            <summary>
            Returns this in-mem transport message's headers and body in a <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Transport.InMem.InMemTransportMessageExtensions">
            <summary>
            Extensions that make it nice to work with <see cref="T:Rebus.Transport.InMem.InMemTransportMessage"/> and <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.InMem.InMemTransportMessageExtensions.ToInMemTransportMessage(Rebus.Messages.TransportMessage)">
            <summary>
            Returns a new <see cref="T:Rebus.Transport.InMem.InMemTransportMessage"/> containing the headers and the body data of the <see cref="T:Rebus.Messages.TransportMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Transport.ITransport">
            <summary>
            The transport is responsible for sending and receiving messages
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransport.CreateQueue(System.String)">
            <summary>
            Must create a queue with the given address
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransport.Send(System.String,Rebus.Messages.TransportMessage,Rebus.Transport.ITransactionContext)">
            <summary>
            Sends the given <see cref="T:Rebus.Messages.TransportMessage"/> to the queue with the specified globally addressable name
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransport.Receive(Rebus.Transport.ITransactionContext,System.Threading.CancellationToken)">
            <summary>
            Receives the next message (if any) from the transport's input queue <see cref="P:Rebus.Transport.ITransport.Address"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.ITransport.Address">
            <summary>
            Gets the global address of the transport's input queue
            </summary>
        </member>
        <member name="T:Rebus.Transport.DefaultTransactionContext">
            <summary>
            Default implementation of <see cref="T:Rebus.Transport.ITransactionContext"/>
            </summary>
        </member>
        <member name="P:Rebus.Transport.DefaultTransactionContext.Items">
            <summary>
            Stash of items that can carry stuff for later use in the transaction
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.OnCommitted(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Registers a listener to be called when the queue transaction is committed. This hook is reserved for the queue transaction
            and you may get unpredictable results of you enlist your own transaction in this
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.OnCompleted(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Registers a listener to be called AFTER the queue transaction has been successfully committed (i.e. all listeners
            registered with <see cref="M:Rebus.Transport.ITransactionContext.OnCommitted(System.Func{System.Threading.Tasks.Task})"/> have been executed). This would be a good place to complete the incoming
            message.
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.OnAborted(System.Action)">
            <summary>
            Registers a listener to be called when the queue transaction is aborted. This hook is reserved for the queue transaction
            and you may get unpredictable results of you enlist your own transaction in this
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.OnDisposed(System.Action)">
            <summary>
            Registers a listener to be called after the transaction is over
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.Abort">
            <summary>
            Indicates that the transaction must not be committed and commit handlers must not be run
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.Commit">
            <summary>
            Executes commit actions enlisted in the transaction with <see cref="M:Rebus.Transport.ITransactionContext.OnCommitted(System.Func{System.Threading.Tasks.Task})"/>
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.Dispose">
            <summary>
            Performs the registered cleanup actions. If the transaction has not been committed, it will be aborted before the cleanup happens.
            </summary>
        </member>
        <member name="M:Rebus.Transport.DefaultTransactionContext.Complete">
            <summary>
            Ends the current transaction by either committing it or aborting it, depending on whether someone voted for abortion
            </summary>
        </member>
        <member name="T:Rebus.Transport.ITransactionContext">
            <summary>
            Represents the context of one queue transaction
            </summary>
        </member>
        <member name="P:Rebus.Transport.ITransactionContext.Items">
            <summary>
            Stash of items that can carry stuff for later use in the transaction
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnCommitted(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Registers a listener to be called when the queue transaction is committed. This hook is reserved for the queue transaction
            and you may get unpredictable results of you enlist your own transaction in this
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnAborted(System.Action)">
            <summary>
            Registers a listener to be called when the queue transaction is aborted. This hook is reserved for the queue transaction
            and you may get unpredictable results of you enlist your own transaction in this
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnCompleted(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Registers a listener to be called AFTER the queue transaction has been successfully committed (i.e. all listeners
            registered with <see cref="M:Rebus.Transport.ITransactionContext.OnCommitted(System.Func{System.Threading.Tasks.Task})"/> have been executed). This would be a good place to complete the incoming
            message.
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.OnDisposed(System.Action)">
            <summary>
            Registers a listener to be called after the transaction is over
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.Abort">
            <summary>
            Signals that something is wrong and the queue transaction must be aborted
            </summary>
        </member>
        <member name="M:Rebus.Transport.ITransactionContext.Commit">
            <summary>
            Executes commit actions enlisted in the transaction with <see cref="M:Rebus.Transport.ITransactionContext.OnCommitted(System.Func{System.Threading.Tasks.Task})"/>
            </summary>
        </member>
        <member name="T:Rebus.Workers.ISyncBackoffStrategy">
            <summary>
            Implements a strategy with which workers will back off in idle periods. Please note that the <see cref="T:Rebus.Workers.ISyncBackoffStrategy"/>
            implementations must be reentrant!
            </summary>
        </member>
        <member name="M:Rebus.Workers.ISyncBackoffStrategy.Wait">
            <summary>
            Executes the next wait operation by blocking the thread, possibly advancing the wait cursor to a different wait time for the next time.
            This function is called each time no message was received.
            </summary>
        </member>
        <member name="M:Rebus.Workers.ISyncBackoffStrategy.WaitError">
            <summary>
            Blocks the thread for a (most likely longer) while, when an error has occurred
            </summary>
        </member>
        <member name="M:Rebus.Workers.ISyncBackoffStrategy.Reset">
            <summary>
            Resets the strategy. Is called whenever a message was received.
            </summary>
        </member>
        <member name="T:Rebus.Workers.IWorker">
            <summary>
            Represents a worker, which is a thing that is capable of doing work. It may correspond to a worker thread
            if the usual Rebus worker threads are used, but it may be possible to do other stuff as well
            </summary>
        </member>
        <member name="P:Rebus.Workers.IWorker.Name">
            <summary>
            Gets the name of the worker. Each worker will be named so that they can be recognized
            </summary>
        </member>
        <member name="M:Rebus.Workers.IWorker.Stop">
            <summary>
            Signals that the worker should try to stop itself because it will be thrown out and disposed in a little while
            </summary>
        </member>
        <member name="T:Rebus.Workers.IBackoffStrategy">
            <summary>
            Implements a strategy with which workers will back off in idle periods. Please note that the <see cref="T:Rebus.Workers.IBackoffStrategy"/>
            implementations must be reentrant!
            </summary>
        </member>
        <member name="M:Rebus.Workers.IBackoffStrategy.Wait">
            <summary>
            Asynchronously executes the next wait operation, possibly advancing the wait cursor to a different wait time for the next time.
            This function is called each time no message was received.
            </summary>
        </member>
        <member name="M:Rebus.Workers.IBackoffStrategy.WaitError">
            <summary>
            Asynchronously waits a while when an error has occurred
            </summary>
        </member>
        <member name="M:Rebus.Workers.IBackoffStrategy.Reset">
            <summary>
            Resets the strategy. Is called whenever a message was received.
            </summary>
        </member>
        <member name="T:Rebus.Workers.ThreadBased.ThreadWorker">
            <summary>
            Implementation of <see cref="T:Rebus.Workers.IWorker"/> that has a dedicated thread the continuously polls the given <see cref="T:Rebus.Workers.ThreadBased.ThreadWorkerSynchronizationContext"/> for work,
            and in case it doesn't find any, it'll try to receive a new message and invoke a receive pipeline on that
            </summary>
        </member>
        <member name="P:Rebus.Workers.ThreadBased.ThreadWorker.Name">
            <summary>
            Gets the name of this thread worker
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorker.Stop">
            <summary>
            Stops this thread worker
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorker.Dispose">
            <summary>
            Stops the thread worker, waiting for it to finish whatever it was doing (up to 5 seconds)
            </summary>
        </member>
        <member name="T:Rebus.Workers.ThreadBased.ThreadWorkerSynchronizationContext">
            <summary>
            Derivation of <see cref="T:System.Threading.SynchronizationContext"/> that queues posted callbacks, allowing for worker threads to retrieve them later 
            on as a simple, callable <see cref="T:System.Action"/>, by calling <see cref="M:Rebus.Workers.ThreadBased.ThreadWorkerSynchronizationContext.GetNextContinuationOrNull"/>
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorkerSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            This method is called when a <see cref="T:System.Threading.Tasks.Task"/> has finished and is ready to be continued
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorkerSynchronizationContext.GetNextContinuationOrNull">
            <summary>
            Gets the next ready continuation if any, returns null otherwise
            </summary>
        </member>
        <member name="T:Rebus.Workers.ThreadBased.ThreadWorkerFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Workers.IWorkerFactory"/> that creates <see cref="T:Rebus.Workers.ThreadBased.ThreadWorker"/> instances when asked for
            an <see cref="T:Rebus.Workers.IWorker"/>. Each <see cref="T:Rebus.Workers.ThreadBased.ThreadWorker"/> has its own dedicated worker thread that performs
            all the work (which consists of receiving new messages and running continuations)
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorkerFactory.#ctor(Rebus.Transport.ITransport,Rebus.Pipeline.IPipeline,Rebus.Pipeline.IPipelineInvoker,Rebus.Workers.IBackoffStrategy,Rebus.Logging.IRebusLoggerFactory,Rebus.Config.Options,System.Func{Rebus.Bus.RebusBus})">
            <summary>
            Constructs the worker factory
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadBased.ThreadWorkerFactory.CreateWorker(System.String)">
            <summary>
            Creates a new worker (i.e. a new thread) with the given name
            </summary>
        </member>
        <member name="T:Rebus.Workers.IWorkerFactory">
            <summary>
            Factory responsible for creating a "worker"
            </summary>
        </member>
        <member name="M:Rebus.Workers.IWorkerFactory.CreateWorker(System.String)">
            <summary>
            Must create a new worker with the given name
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultSyncBackoffStrategy.#ctor(System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Constructs the backoff strategy with the given waiting times
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultSyncBackoffStrategy.Wait">
            <summary>
            Executes the next wait operation by blocking the thread, possibly advancing the wait cursor to a different wait time for the next time.
            This function is called each time no message was received.
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultSyncBackoffStrategy.WaitError">
            <summary>
            Blocks the thread for a (most likely longer) while, when an error has occurred
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DefaultSyncBackoffStrategy.Reset">
            <summary>
            Resets the strategy. Is called whenever a message was received.
            </summary>
        </member>
        <member name="T:Rebus.Workers.ThreadPoolBased.DedicatedRebusWorkersConfigurationExtensions">
            <summary>
            Configuration extensions for classic dedicated Rebus worker factory
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.DedicatedRebusWorkersConfigurationExtensions.UseClassicRebusWorkersMessageDispatch(Rebus.Config.OptionsConfigurer)">
            <summary>
            Replaces the default thread pool-based worker factory with one that uses dedicate Rebus workers for everything (including running continuations)
            </summary>
        </member>
        <member name="T:Rebus.Workers.ThreadPoolBased.ThreadPoolWorkerFactory">
            <summary>
            Implementation of <see cref="T:Rebus.Workers.IWorkerFactory"/> that uses worker threads to do synchronous receive of messages, dispatching
            received messages to the threadpool.
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.ThreadPoolWorkerFactory.#ctor(Rebus.Transport.ITransport,Rebus.Logging.IRebusLoggerFactory,Rebus.Pipeline.IPipeline,Rebus.Pipeline.IPipelineInvoker,Rebus.Config.Options,System.Func{Rebus.Bus.RebusBus},Rebus.Bus.BusLifetimeEvents,Rebus.Workers.ISyncBackoffStrategy)">
            <summary>
            Creates the worker factory
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.ThreadPoolWorkerFactory.CreateWorker(System.String)">
            <summary>
            Creates a new worker with the given <paramref name="workerName"/>
            </summary>
        </member>
        <member name="M:Rebus.Workers.ThreadPoolBased.ThreadPoolWorkerFactory.WaitForContinuationsToFinish">
            <summary>
            Blocks until all work has finished being done (i.e. waits for all message handling continuations to have been executed)
            </summary>
        </member>
        <member name="T:Rebus.Logging.AbstractRebusLoggerFactory">
            <summary>
            If you intend to implement your own logging, you probably want to derive
            from this class and implement <seealso cref="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)"/>.
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)">
            <summary>
            Should get a logger for the specified type 
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetCurrentClassLogger">
            <summary>
            Gets a logger that is initialized to somehow carry information on the class that is using it.
            Be warned that this method will most likely be pretty slow, because it will probably rely on
            some clunky <see cref="T:System.Diagnostics.StackFrame"/> inspection.
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger``1">
            <summary>
            Gets a logger for the type <typeparamref name="T"/>
            </summary>
        </member>
        <member name="T:Rebus.Logging.ColorSetting">
            <summary>
            Represents a console color setting consisting of a foreground and a background color
            </summary>
        </member>
        <member name="P:Rebus.Logging.ColorSetting.ForegroundColor">
            <summary>
            Gets the foreground color
            </summary>
        </member>
        <member name="P:Rebus.Logging.ColorSetting.BackgroundColor">
            <summary>
            Gets the background color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Foreground(System.ConsoleColor)">
            <summary>
            Sets the foreground color to the specified color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Background(System.ConsoleColor)">
            <summary>
            Sets the background color to the specified color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Enter">
            <summary>
            Sets the current console colors to those specified in this <see cref="T:Rebus.Logging.ColorSetting"/>,
            restoring them to the previous colors when disposing
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerFactory">
            <summary>
            Logger factory that logs stuff to the console
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerFactory.LogStatement">
            <summary>
            One single log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Level">
            <summary>
            The level of this log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Text">
            <summary>
            The text (possibly inclusing formatting placeholders) of this log statement
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Args">
            <summary>
            The values to use for string interpolation
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.LogStatement.Type">
            <summary>
            The type to which this particular logger belongs
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerFactory.#ctor(System.Boolean)">
            <summary>
            Constructs the logger factory
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.Colors">
            <summary>
            Gets or sets the colors to use when logging
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.MinLevel">
            <summary>
            Gets or sets the minimum logging level to output to the console
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.Filters">
            <summary>
            Gets the list of filters that each log statement will be passed through in order to evaluate whether
            the given log statement should be output to the console
            </summary>
        </member>
        <member name="P:Rebus.Logging.ConsoleLoggerFactory.ShowTimestamps">
            <summary>
            Gets/sets whether timestamps should be shown when logging
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a logger for logging stuff from within the specified type
            </summary>
        </member>
        <member name="T:Rebus.Logging.ILog">
            <summary>
            Interface of a Rebus logger
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Debug(System.String,System.Object[])">
            <summary>
            Writes the specified message with the DEBUG level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Info(System.String,System.Object[])">
            <summary>
            Writes the specified message with the INFO level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Warn(System.String,System.Object[])">
            <summary>
            Writes the specified message with the WARN level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Writes the specified message with the ERROR level and includes the full details of the specified exception
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Error(System.String,System.Object[])">
            <summary>
            Writes the specified message with the ERROR level
            </summary>
        </member>
        <member name="T:Rebus.Logging.IRebusLoggerFactory">
            <summary>
            Basic interface of a Rebus logger factory. If you intend to implement your own,
            <see cref="T:Rebus.Logging.AbstractRebusLoggerFactory"/> is the one to derive from - you should
            probably not implement this interface directly.
            </summary>
        </member>
        <member name="M:Rebus.Logging.IRebusLoggerFactory.GetCurrentClassLogger">
            <summary>
            Gets a logger that is initialized to somehow carry information on the class that is using it.
            Be warned that this method will most likely be pretty slow, because it will probably rely on
            some clunky <see cref="T:System.Diagnostics.StackFrame"/> inspection.
            </summary>
        </member>
        <member name="M:Rebus.Logging.IRebusLoggerFactory.GetLogger``1">
            <summary>
            Gets a logger for the type <typeparamref name="T"/>
            </summary>
        </member>
        <member name="T:Rebus.Logging.LoggingColors">
            <summary>
            Represents a set of colors to be used by the <see cref="T:Rebus.Logging.ConsoleLoggerFactory"/> when running
            in colored mode
            </summary>
        </member>
        <member name="M:Rebus.Logging.LoggingColors.#ctor">
            <summary>
            Constructs the default set of logging colors, which if gray, green, yellow, and red foreground for log
            levels debug, info, warn, and error respectively.
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Debug">
            <summary>
            Gets/sets the color to use when printing DEBUG log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Info">
            <summary>
            Gets/sets the color to use when printing INFO log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Warn">
            <summary>
            Gets/sets the color to use when printing WARN log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Error">
            <summary>
            Gets/sets the color to use when printing ERROR log statements
            </summary>
        </member>
        <member name="T:Rebus.Logging.LogLevel">
            <summary>
            Enumeration of the log levels available with Rebus loggers. As a general rule of thumb, levels WARN
            and ERROR should, as a minimum, ALWAYS be logged to a local file or another persistent means.
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Debug">
            <summary>
            Log statement of very low importance which is most likely only relevant in extreme debugging scenarios
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Info">
            <summary>
            Log statement of low importance to unwatched running systems which however can be very relevant when testing and debugging
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Warn">
            <summary>
            Log statement of fairly high importance - always contains relevant information on somewhing that may be a sign that something is wrong
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Error">
            <summary>
            Log statement of the highest importance - always contains relevant information on something that has gone wrong
            </summary>
        </member>
        <member name="T:Rebus.Logging.NullLoggerFactory">
            <summary>
            This is the /dev/null of loggers...
            </summary>
        </member>
        <member name="M:Rebus.Logging.NullLoggerFactory.GetLogger(System.Type)">
            <summary>
            Returns a <see cref="T:Rebus.Logging.NullLoggerFactory.NullLogger"/> which is the /dev/null of logging...
            </summary>
        </member>
        <member name="T:Rebus.Logging.TraceLoggerFactory">
            <summary>
            Logger factory that writes log statements using the <see cref="T:System.Diagnostics.Trace"/> API
            </summary>
        </member>
        <member name="M:Rebus.Logging.TraceLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a <see cref="T:Rebus.Logging.TraceLoggerFactory.TraceLogger"/>
            </summary>
        </member>
        <member name="T:Rebus.Subscriptions.ISubscriptionStorage">
            <summary>
            Abstraction that handles how subscriptions are stored
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.GetSubscriberAddresses(System.String)">
            <summary>
            Gets all destination addresses for the given topic
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.RegisterSubscriber(System.String,System.String)">
            <summary>
            Registers the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="M:Rebus.Subscriptions.ISubscriptionStorage.UnregisterSubscriber(System.String,System.String)">
            <summary>
            Unregisters the given <paramref name="subscriberAddress"/> as a subscriber of the given topic
            </summary>
        </member>
        <member name="P:Rebus.Subscriptions.ISubscriptionStorage.IsCentralized">
            <summary>
            Gets whether the subscription storage is centralized and thus supports bypassing the usual subscription request
            (in a fully distributed architecture, a subscription is established by sending a <see cref="T:Rebus.Messages.Control.SubscribeRequest"/>
            to the owner of a given topic, who then remembers the subscriber somehow - if the subscription storage is
            centralized, the message exchange can be bypassed, and the subscription can be established directly by
            having the subscriber register itself)
            </summary>
        </member>
    </members>
</doc>
